Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revisione 39518)
+++ CMakeLists.txt	(copia locale)
@@ -108,6 +108,7 @@
 option(WITH_BULLET        "Enable Bullet (Physics Engine)" ON)
 option(WITH_GAMEENGINE    "Enable Game Engine" ON)
 option(WITH_PLAYER        "Build Player" OFF)
+option(WITH_FBT           "Enable BGE converted file saving/loading" ON)
 
 # GHOST Windowing Library Options
 option(WITH_GHOST_DEBUG   "Enable debugging output for the GHOST library" OFF)
@@ -224,6 +225,10 @@
 	message(FATAL_ERROR "WITH_PLAYER requires WITH_GAMEENGINE")
 endif()
 
+if(NOT WITH_GAMEENGINE AND WITH_FBT)
+	message(FATAL_ERROR "WITH_FBT requires WITH_GAMEENGINE")
+endif()
+
 if(NOT WITH_AUDASPACE AND (WITH_OPENAL OR WITH_SDL OR WITH_JACK))
 	message(FATAL_ERROR "WITH_OPENAL/WITH_SDL/WITH_JACK/WITH_CODEC_FFMPEG require WITH_AUDASPACE")
 endif()
@@ -527,12 +532,12 @@
 	# this file is included anyway when building under Windows with cl.exe
 	#  include(${CMAKE_ROOT}/Modules/Platform/Windows-cl.cmake)
 
-	set(LIBDIR ${CMAKE_SOURCE_DIR}/../lib/windows)
+	set(LIBDIR ${CMAKE_SOURCE_DIR}/../../BlenderSVN/lib/windows)
 
 	# Setup 64bit and 64bit windows systems
 	if(CMAKE_CL_64)
 		message("64 bit compiler detected.")
-		set(LIBDIR ${CMAKE_SOURCE_DIR}/../lib/win64)
+		set(LIBDIR ${CMAKE_SOURCE_DIR}/../../BlenderSVN/lib/windows)
 	endif()
 	
 	add_definitions(-DWIN32)
@@ -1355,7 +1360,8 @@
 	info_cfg_option(WITH_FFTW3)
 	info_cfg_option(WITH_INTERNATIONAL)
 	info_cfg_option(WITH_INPUT_NDOF)
-
+	info_cfg_option(WITH_FBT)
+	
 	info_cfg_text("Compiler Options:")
 	info_cfg_option(WITH_BUILDINFO)
 	info_cfg_option(WITH_OPENMP)
Index: extern/CMakeLists.txt
===================================================================
--- extern/CMakeLists.txt	(revisione 39518)
+++ extern/CMakeLists.txt	(copia locale)
@@ -58,3 +58,7 @@
 if(WITH_LZMA)
 	add_subdirectory(lzma)
 endif()
+
+if(WITH_FBT)
+	add_subdirectory(FileTools)
+endif()
Index: extern/FileTools/CMakeLists.txt
===================================================================
--- extern/FileTools/CMakeLists.txt	(revisione 0)
+++ extern/FileTools/CMakeLists.txt	(revisione 0)
@@ -0,0 +1,47 @@
+#------------------------------------------------------------------------------
+#   This file is part of FBT (File Binary Tables).
+#   http://gamekit.googlecode.com/
+#
+#   Copyright (c) 2010 Charlie C & Erwin Coumans.
+#
+#------------------------------------------------------------------------------
+# This software is provided 'as-is', without any express or implied
+# warranty. In no event will the authors be held liable for any damages
+# arising from the use of this software.
+#
+# Permission is granted to anyone to use this software for any purpose,
+# including commercial applications, and to alter it and redistribute it
+# freely, subject to the following restrictions:
+#
+# 1. The origin of this software must not be misrepresented; you must not
+#    claim that you wrote the original software. If you use this software
+#    in a product, an acknowledgment in the product documentation would be
+#    appreciated but is not required.
+# 2. Altered source versions must be plainly marked as such, and must not be
+#    misrepresented as being the original software.
+# 3. This notice may not be removed or altered from any source distribution.
+#------------------------------------------------------------------------------
+#cmake_minimum_required(VERSION 2.4)
+#if(COMMAND cmake_policy)
+#    cmake_policy(SET CMP0003 NEW)
+#endif(COMMAND cmake_policy)
+
+#project(FBT)
+
+set(FBT_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})
+
+#list(APPEND CMAKE_MODULE_PATH ${FBT_SOURCE_DIR}/CMake)
+
+#if(OGREKIT_ZLIB_TARGET) #use ZLib in Ogrekit dependence libraries
+#	set(FBT_USE_ZLIB 1)
+#	set(FBT_ZLIB_INCLUDE ${OGREKIT_ZLIB_INCLUDE})
+#	set(FBT_ZLIB_LIBRARY ${OGREKIT_ZLIB_TARGET})	
+#else()
+#	message(STATUS "Can't found ZLib: ftbFile don't support compressed file.")
+#endif()
+
+#if (FBT_USE_ZLIB)
+#    add_definitions(-DFBT_USE_GZ_FILE=1)
+#endif()
+
+subdirs(File)
\ No newline at end of file
Index: extern/FileTools/File/CMakeLists.txt
===================================================================
--- extern/FileTools/File/CMakeLists.txt	(revisione 0)
+++ extern/FileTools/File/CMakeLists.txt	(revisione 0)
@@ -0,0 +1,63 @@
+#------------------------------------------------------------------------------
+#   This file is part of FBT (File Binary Tables).
+#   http://gamekit.googlecode.com/
+#
+#   Copyright (c) 2010 Charlie C & Erwin Coumans.
+#
+#------------------------------------------------------------------------------
+# This software is provided 'as-is', without any express or implied
+# warranty. In no event will the authors be held liable for any damages
+# arising from the use of this software.
+#
+# Permission is granted to anyone to use this software for any purpose,
+# including commercial applications, and to alter it and redistribute it
+# freely, subject to the following restrictions:
+#
+# 1. The origin of this software must not be misrepresented; you must not
+#    claim that you wrote the original software. If you use this software
+#    in a product, an acknowledgment in the product documentation would be
+#    appreciated but is not required.
+# 2. Altered source versions must be plainly marked as such, and must not be
+#    misrepresented as being the original software.
+# 3. This notice may not be removed or altered from any source distribution.
+#------------------------------------------------------------------------------
+#include(FlexBison)
+
+set(File_SRC
+    fbtFile.cpp
+    fbtTables.cpp    
+    fbtTypes.cpp
+    fbtStreams.cpp
+	fbtBuilder.cpp
+)
+
+set(File_HDR
+    fbtFile.h
+    fbtTables.h
+    fbtBuilder.h
+    fbtTypes.h
+    fbtConfig.h
+    fbtStreams.h
+    fbtPlatformHeaders.h
+)
+
+set(fbtScanner Generated/fbtScanner.inl)
+
+#if (FBT_USE_ZLIB)
+#    include_directories(${FBT_ZLIB_INCLUDE})
+#    link_libraries(${FBT_ZLIB_LIBRARY})
+#endif()
+
+#this is the original line, i added a few other things i see used in other cmakelists
+add_library(extern_fbtfile ${File_SRC} ${File_HDR} ${fbtScanner})
+set_property(GLOBAL APPEND PROPERTY BLENDER_LINK_LIBS extern_fbtfile)
+set(SOURCE_FILES ${File_SRC} ${File_HDR})
+blender_source_group("${SOURCE_FILES}")
+
+#i think this should set everything fine and should be the preferred solution..
+#set(SOURCE_FILES ${File_SRC})
+#list(APPEND SOURCE_FILES ${File_HDR})
+#list(APPEND SOURCE_FILES ${fbtScanner})
+#set(INC)
+#set(INC_SYS)
+#blender_add_lib(extern_fbtfile ${SOURCE_FILES} INC INC_SYS)
\ No newline at end of file
Index: extern/FileTools/File/fbtBuilder.cpp
===================================================================
--- extern/FileTools/File/fbtBuilder.cpp	(revisione 0)
+++ extern/FileTools/File/fbtBuilder.cpp	(revisione 0)
@@ -0,0 +1,926 @@
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Tables).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+#include "fbtConfig.h"
+#include "fbtBuilder.h"
+#include "fbtStreams.h"
+#include "Generated/fbtScanner.inl"
+#define fbtValidToken(x) (x > 0)
+
+
+typedef fbtArray<FBTtype>   IntPtrArray;
+typedef fbtArray<FBTtype>   TypeArray;
+
+struct MaxAllocSize
+{
+	FBTuint32 m_name;
+	FBTuint32 m_type;
+	FBTuint32 m_tlen;
+	FBTuint32 m_strc;
+	FBTuint32 m_offs;
+};
+
+class fbtBuildInfo
+{
+public:
+
+	fbtBuildInfo();
+	~fbtBuildInfo() {}
+
+
+	void reserve(void);
+	int getLengths(fbtBuildStructs& struct_builders);
+	int getTLengths(fbtBuildStructs& struct_builders);
+
+
+	void makeBuiltinTypes(void);
+
+	bool        hasType(const fbtId& type);
+	FBTsizeType addType(const fbtId& type, const FBTuint32& len);
+	FBTsizeType addName(const fbtId& name);
+
+	MaxAllocSize        m_alloc;
+	fbtStringPtrArray   m_name;
+	fbtStringPtrArray   m_type;
+	IntPtrArray         m_tlen;
+	IntPtrArray         m_64ln;
+	TypeArray           m_strc;
+	fbtStringPtrArray   m_undef;
+};
+
+
+
+fbtBuilder::fbtBuilder() 
+	:	m_build(new fbtBuildInfo()),
+		fbt_start(0),
+		m_curBuf(0),
+		m_writeMode(0)
+{
+}
+
+
+fbtBuilder::~fbtBuilder()
+{
+	delete m_build;
+}
+
+
+void fbtBuilder::makeName(fbtVariable& v, bool forceArray)
+{
+
+	fbtId newName;
+	int i = 0, j = 0;
+
+	if (v.m_isFptr)
+		newName.push_back('(');
+
+	if (v.m_ptrCount > 0)
+	{
+		for (i = 0; i < v.m_ptrCount; ++i)
+			newName.push_back('*');
+	}
+
+	for (i = 0; i < v.m_name.size(); ++i)
+		newName.push_back(v.m_name[i]);
+
+	if (v.m_isFptr)
+	{
+		newName.push_back(')');
+		newName.push_back('(');
+		newName.push_back(')');
+	}
+
+	if (v.m_arraySize > 1 || forceArray)
+	{
+		for (i = 0; i < v.m_numSlots; ++i)
+		{
+			newName.push_back('[');
+
+			fbtId dest;
+			sprintf(dest.ptr(), "%i", v.m_arrays[i]);
+			//itoa(v.m_arrays[i], dest.ptr(), 10);
+			char* cp = dest.ptr();
+
+			for (j = 0; cp[j]; ++j)
+				newName.push_back(cp[j]);
+
+			newName.push_back(']');
+		}
+	}
+
+	v.m_name = newName;
+}
+
+
+int fbtBuilder::parseBuffer(const fbtId& name, const char* ms)
+{
+	fbtParser parser = fbtInitParse(name.c_str(), ms);
+	fbt_includes.push_back(name.c_str());
+
+	if (!parser)
+	{
+		fbtPrintf("Error : Parser initialization failed!\n");
+		return -1;
+	}
+
+	int ret = doParse();
+	fbtFreeParse(parser);
+	return ret;
+}
+
+
+
+int fbtBuilder::parseFile(const fbtPath& id)
+{
+	fbtParser parser = fbtInitParse(id.c_str());
+	fbt_includes.push_back(id);
+
+	if (!parser)
+	{
+		fbtPrintf("Error : Parser initialization failed!\n");
+		return -1;
+	}
+
+	int ret = doParse();
+	fbtFreeParse(parser);
+	return ret;
+}
+
+int fbtBuilder::doParse(void)
+{
+
+	fbtTokenID TOK = NULL_TOKEN;
+
+
+	while (fbtValidToken(TOK))
+	{
+		TOK = fbtLex();
+
+		if (TOK == NAMESPACE)
+		{
+			fbtToken tp;
+			TOK = fbtLex(tp);
+			if (TOK == IDENTIFIER)
+				fbt_namespaces.push_back(tp.m_buf);
+		}
+
+
+		if (TOK == STRUCT)
+		{
+			fbtToken tp;
+
+			do
+			{
+				TOK = fbtLex(tp);
+
+				if (TOK == IDENTIFIER)
+				{
+					fbtBuildStruct bs;
+					bs.m_name = tp.m_buf;
+					bs.m_path = tp.m_src;
+					bs.m_line = tp.m_line;
+
+
+					TOK = fbtLex(tp);
+					if (TOK == LBRACKET)
+					{
+						do
+						{
+							TOK = fbtLex(tp);
+
+							if (TOK == RBRACKET)
+								break;
+
+							if (TOK == CLASS || TOK == STRUCT)
+								TOK = fbtLex(tp);
+
+							if (FBT_TOK_IS_TYPE(TOK))
+							{
+								fbtId typeId = tp.m_buf;
+
+								// Scan names till ';'
+								fbtVariable cur;
+								cur.m_type          = typeId;
+								cur.m_path          = tp.m_src;
+								cur.m_line          = tp.m_line;
+								cur.m_undefined     = 0;
+
+								bool forceArray = false;
+								bool isId = TOK == IDENTIFIER;
+
+								do
+								{
+
+									TOK = fbtLex(tp);
+
+									switch (TOK)
+									{
+									case RBRACE:
+									case LBRACE:
+										forceArray = true;
+										break;
+									case CONSTANT:
+										if (cur.m_numSlots + 1 > FBT_ARRAY_SLOTS)
+										{
+											fbtPrintf("Maximum number of array slots exceeded!\n");
+											fbtPrintf("define FBT_ARRAY_SLOTS to expand.\nCurrent = [] * %i\n", FBT_ARRAY_SLOTS);
+											return -1;
+										}
+
+										cur.m_arrays[cur.m_numSlots] = tp.m_constantSize;
+										cur.m_numSlots ++;
+										cur.m_arraySize *= tp.m_constantSize;
+										break;
+									case POINTER:
+										cur.m_ptrCount++;
+										break;
+									case IDENTIFIER:
+										cur.m_name = tp.m_buf;
+										break;
+									case FUNCTION_POINTER_BEG:
+										cur.m_isFptr = 1;
+										cur.m_ptrCount++;
+										cur.m_name = tp.m_buf;
+										break;
+									case FUNCTION_POINTER_END:
+										break;
+									case TERM:
+									case COMMA:
+										{
+											makeName(cur, forceArray);
+
+											if (isId && cur.m_ptrCount == 0)
+											{
+												if (bs.m_nrDependentTypes > 0)
+													bs.m_nrDependentTypes = bs.m_nrDependentTypes * 2;
+												else
+													bs.m_nrDependentTypes ++;
+												cur.m_isDependentType = true;
+											}
+
+											bs.m_data.push_back(cur);
+											cur.m_ptrCount = 0;
+											cur.m_arraySize = 1;
+
+											if (TOK == COMMA)
+												cur.m_numSlots = 0;
+										}
+										break;
+									default:
+										{
+											fbtPrintf("%s(%i): error : Unknown character parsed! %s\n", tp.m_src, tp.m_line, tp.m_buf);
+											return -1;
+										}
+										break;
+
+									}
+								}
+								while ((TOK != TERM) && fbtValidToken(TOK));
+							}
+							else
+							{
+								fbtPrintf("%s(%i): error : unknown token parsed %s\n", tp.m_src, tp.m_line, tp.m_buf);
+								return -1;
+							}
+						}
+						while ((TOK != RBRACKET) && fbtValidToken(TOK));
+
+						fbt_struct_builders.push_back(bs);
+					}
+				}
+			}
+			while ((TOK != RBRACKET && TOK != TERM) && fbtValidToken(TOK));
+		}
+	}
+	return 0;
+}
+
+int fbtBuilder::buildTypes(void)
+{
+	return m_build->getLengths(fbt_struct_builders);
+}
+
+
+
+void fbtBuilder::writeFile(const fbtId& id, fbtStream* fp)
+{
+	if (!fp)
+		return;
+
+	fp->writef("unsigned char %sFBT[]={\n", id.c_str());
+
+	m_writeMode = 0;
+	writeStream(fp);
+
+
+	fp->writef("\n};\n");
+	fp->writef("int %sLen=sizeof(%sFBT);\n", id.c_str(), id.c_str());
+
+}
+
+
+void fbtBuilder::writeFile(const fbtId& id, const fbtPath& path)
+{
+	fbtFileStream fp;
+	fp.open(path.c_str(), fbtStream::SM_WRITE);
+	if (!fp.isOpen())
+	{
+		fbtPrintf("Failed to open data file: %s\n", path.c_str());
+		return;
+	}
+
+	fp.writef("unsigned char %sFBT[]={\n", id.c_str());
+
+	m_writeMode = 0;
+	writeStream(&fp);
+
+	fp.writef("\n};\n");
+	fp.writef("int %sLen=sizeof(%sFBT);\n", id.c_str(), id.c_str());
+
+#if FBT_TYPE_LEN_VALIDATE == 1
+	writeValidationProgram(path.c_str());
+#endif
+}
+
+
+void fbtBuilder::writeStream(fbtStream* fp)
+{
+	m_curBuf = -1;
+
+
+	int i;
+	writeBinPtr(fp, (void*)&fbtIdNames::FBT_SDNA[0], 4);
+
+
+	writeBinPtr(fp, (void*)&fbtIdNames::FBT_NAME[0], 4);
+	i = m_build->m_name.size();
+#if FBT_FAKE_ENDIAN == 1
+	i = fbtSwap32(i);
+#endif
+	writeBinPtr(fp, &i, 4);
+	writeCharPtr(fp, m_build->m_name);
+
+
+	writeBinPtr(fp, (void*)&fbtIdNames::FBT_TYPE[0], 4);
+	i = m_build->m_type.size();
+#if FBT_FAKE_ENDIAN == 1
+	i = fbtSwap32(i);
+#endif
+	writeBinPtr(fp, &i, 4);
+	writeCharPtr(fp, m_build->m_type);
+
+	writeBinPtr(fp, (void*)&fbtIdNames::FBT_TLEN[0], 4);
+#if FBT_FAKE_ENDIAN == 1
+	for (i = 0; i < (int)m_build->m_tlen.size(); i++)
+		m_build->m_tlen.at(i) = fbtSwap16(m_build->m_tlen.at(i));
+#endif
+
+	writeBinPtr(fp, m_build->m_tlen.ptr(), m_build->m_alloc.m_tlen);
+	if ( m_build->m_tlen.size() & 1 )
+	{
+		char pad[2] = {'@', '@'};
+		writeBinPtr(fp, (void*)&pad[0], 2);
+	}
+
+	writeBinPtr(fp, (void*)&fbtIdNames::FBT_STRC[0], 4);
+	i = fbt_struct_builders.size();
+#if FBT_FAKE_ENDIAN == 1
+	i = fbtSwap32(i);
+#endif
+	writeBinPtr(fp, &i, 4);
+
+
+
+#if FBT_FAKE_ENDIAN == 1
+	for (i = 0; i < (int) m_build->m_strc.size(); i++)
+		m_build->m_strc.at(i) = fbtSwap16( m_build->m_strc.at(i));
+#endif
+
+	writeBinPtr(fp,  m_build->m_strc.ptr(), m_build->m_alloc.m_strc);
+
+}
+
+
+void fbtBuilder::writeCharPtr(fbtStream* fp, const fbtStringPtrArray& ptrs)
+{
+	char pad[4] = {'b', 'y', 't', 'e'};
+	FBTsize i = 0, s = ptrs.size();
+	int t = 0;
+
+
+	while (i < s)
+	{
+		fbtId id = ptrs[i++];
+		id.push_back('\0');
+		writeBinPtr(fp, (void*)id.c_str(), id.size());
+
+		t += id.size();
+	}
+
+	int len = t;
+	len = (len + 3) & ~3;
+
+	if (len - t)
+	{
+		fbtId id;
+		int p;
+		for (p = 0; p < (len - t); p++)
+			id.push_back(pad[p%4]);
+
+		writeBinPtr(fp, (void*)id.c_str(), id.size());
+	}
+
+
+}
+
+
+void fbtBuilder::writeBinPtr(fbtStream* fp, void* ptr, int len)
+{
+	if (m_writeMode == 0)
+	{
+		unsigned char* cb = (unsigned char*)ptr;
+		for (int i = 0; i < len; ++i, ++m_curBuf)
+		{
+			if ((m_curBuf % 24) == (23))
+				fp->writef("\n");
+
+			unsigned char cp = cb[i];
+			fp->writef("0x%02X,", cp);
+		}
+	}
+	else
+	{
+		fp->write(ptr, len);
+	}
+}
+
+fbtBinTables* fbtBuilder::write(void)
+{
+	fbtMemoryStream ms;
+	ms.open(fbtStream::SM_WRITE);
+	m_writeMode = -1;
+
+	writeStream(&ms);
+
+	void* buffer = fbtMalloc(ms.size() + 1);
+	fbtMemcpy(buffer, ms.ptr(), ms.size());
+
+	return new fbtBinTables(buffer, ms.size());
+}
+
+
+void fbtBuilder::writeValidationProgram(const fbtPath& path)
+{
+#if FBT_TYPE_LEN_VALIDATE == 1
+
+	fbtPath string;
+	fbtPathArray split;
+	path.split(split, '/', '\\');
+
+	// find split points
+
+
+	int i;
+	int last = 0;
+	for (i = path.size()-1; i > 0; --i)
+	{
+		if (path[i] == '.') 
+		{
+			last = i;
+			break;
+		}
+	}
+
+	
+	
+	for (i = 0; i < path.size(); ++i)
+	{
+		if (i >= last)
+			break;
+
+		string.push_back(path[i]);
+	}
+	string += "Validator.cpp";
+
+
+
+	//fbtPrintf("Writing Validator for ==> %s\n", string.c_str());
+
+	FILE* fp = fopen(string.c_str(), "wb");
+	if (!fp)
+	{
+		fbtPrintf("Failed to open validator file %s\n", string.c_str());
+		return;
+	}
+
+
+	for (i = 0; i < (int)fbt_includes.size(); ++i)
+	{
+		split.clear(true);
+		fbt_includes[i].split(split, '/', '\\');
+
+		fprintf(fp, "#include \"%s\"\n", fbt_includes[i].c_str());
+	}
+
+	fprintf(fp, "#include <stdlib.h>\n");
+	fprintf(fp, "#include <stdio.h>\n\n");
+	if (!fbt_namespaces.empty())
+	{
+		for (i = 0; i < (int)fbt_namespaces.size(); ++i)
+			fprintf(fp, "using namespace %s;\n\n\n", fbt_namespaces[i].c_str());
+	}
+
+	fprintf(fp, "int main()\n{\n\tint errors=0;\n");
+
+
+
+	fbtBuildStructs::Iterator it = fbt_struct_builders.iterator();
+
+	while (it.hasMoreElements())
+	{
+		fbtBuildStruct& bs = it.getNext();
+
+		fbtId& cur = m_build->m_type.at(bs.m_structId);
+		FBTtype len = m_build->m_tlen.at(bs.m_structId);
+
+		if (fbt_skip.find(cur) != FBT_NPOS)
+			continue;
+
+
+
+#if FBT_FAKE_ENDIAN == 1
+		len = fbtSwap16(len);
+#endif
+		fprintf(fp, "\t");
+		fprintf(fp, "if (sizeof(%s) != %i)\n\t{\n\t\terrors ++;\n", cur.c_str(), len);
+		fprintf(fp, "#ifdef _MSC_VER\n");
+		fprintf(fp, "\t\tfprintf(stderr, \"%%s(%%i): error : Validation failed with ( %%i = sizeof(%s) ) != %%i\\n\", __FILE__, __LINE__, (int)sizeof(%s), %i);\n", cur.c_str(), cur.c_str(), len);
+		fprintf(fp, "#else\n");
+		fprintf(fp, "\t\tfprintf(stderr, \"%%s:%%i: error : Validation failed with ( %%i = sizeof(%s) ) != %%i\\n\", __FILE__, __LINE__, (int)sizeof(%s), %i);\n", cur.c_str(), cur.c_str(), len);
+		fprintf(fp, "#endif\n");
+		fprintf(fp, "\t}\n");
+		fprintf(fp, "\n");
+	}
+
+	fprintf(fp, "\t");
+	fprintf(fp, "if (errors > 0)fprintf(stderr, \"%%s(%%i): error : there are %%i misaligned types.\\n\", __FILE__, __LINE__, errors);\n");
+
+	fprintf(fp, "\treturn errors == 0 ? 0 : 1;\n}\n");
+
+
+#endif
+
+	fclose(fp);
+
+}
+
+
+
+
+
+fbtBuildInfo::fbtBuildInfo()
+{
+	m_alloc.m_name = 0;
+	m_alloc.m_type = 0;
+	m_alloc.m_tlen = 0;
+	m_alloc.m_strc = 0;
+	m_alloc.m_offs = 0;
+}
+
+
+void fbtBuildInfo::reserve(void)
+{
+	m_name.reserve(fbtMaxTable);
+	m_type.reserve(fbtMaxTable);
+	m_tlen.reserve(fbtMaxTable);
+	m_strc.reserve(fbtMaxTable * fbtMaxMember);
+}
+
+
+
+void fbtBuildInfo::makeBuiltinTypes(void)
+{
+	addType("char",         sizeof(char));
+	addType("uchar",        sizeof(char));
+	addType("short",        sizeof(short));
+	addType("ushort",       sizeof(short));
+	addType("int",          sizeof(int));
+	addType("long",         sizeof(long));
+	addType("ulong",        sizeof(long));
+	addType("float",        sizeof(float));
+	addType("double",       sizeof(double));
+#ifdef FBT_USE_SCALAR
+	addType(FBT_SCALAR,     sizeof(scalar_t));
+#endif
+	addType("void",         0);
+}
+
+
+
+FBTsizeType fbtBuildInfo::addType(const fbtId& type, const FBTuint32& len)
+{
+	FBTsize loc;
+	if ((loc = m_type.find(type)) == FBT_NPOS)
+	{
+		m_alloc.m_type += type.size() + 1;
+		m_alloc.m_tlen += sizeof(FBTtype);
+
+		loc = m_type.size();
+
+		m_type.push_back(type);
+		m_tlen.push_back(len);
+		m_64ln.push_back(len);
+	}
+	return loc;
+}
+
+bool fbtBuildInfo::hasType(const fbtId& type)
+{
+	return m_type.find(type) != FBT_NPOS;
+}
+
+
+FBTsizeType fbtBuildInfo::addName(const fbtId& name)
+{
+	FBTsize loc;
+	if ((loc = m_name.find(name)) == FBT_NPOS)
+	{
+		m_alloc.m_name += name.size() + 1;
+		loc = m_name.size();
+
+		m_name.push_back(name);
+	}
+	return loc;
+}
+
+
+int fbtBuildInfo::getLengths(fbtBuildStructs& struct_builders)
+{
+
+
+	makeBuiltinTypes();
+
+	fbtBuildStructs::Iterator bit = struct_builders.iterator();
+	while (bit.hasMoreElements())
+	{
+		fbtBuildStruct& bs = bit.getNext();
+		bs.m_structId = addType(bs.m_name, 0);
+
+		m_strc.push_back(bs.m_structId);
+		m_strc.push_back((FBTint16)bs.m_data.size());
+
+		m_alloc.m_strc += (sizeof(FBTtype) * 2);
+
+
+		fbtVariables::Iterator it = bs.m_data.iterator();
+		while (it.hasMoreElements())
+		{
+			fbtVariable& cvar = it.getNext();
+
+			cvar.m_typeId = addType(cvar.m_type, 0);
+			cvar.m_nameId = addName(cvar.m_name);
+
+			m_strc.push_back(cvar.m_typeId);
+			m_strc.push_back(cvar.m_nameId);
+
+			m_alloc.m_strc += (sizeof(FBTtype) * 2);
+		}
+	}
+
+	return getTLengths(struct_builders);
+}
+
+
+int fbtBuildInfo::getTLengths(fbtBuildStructs& struct_builders)
+{
+
+	fbtBuildStruct* strcs = struct_builders.ptr();
+	FBTsize tot = struct_builders.size(), i, e;
+
+	int next = tot, prev = 0;
+
+	FBTtype* tln64 = m_64ln.ptr();
+	FBTtype* tlens = m_tlen.ptr();
+	FBTsize nrel = 0, ct, len, fake64;
+
+	int status = LNK_OK;
+
+	fbtStringPtrArray m_missingReport, m_zpdef;
+
+
+	FBTtype fbt_start = 0;
+	if (strcs)
+		fbt_start = strcs[0].m_structId;
+
+	fbtVariable* vptr = 0;
+
+
+
+	while (next != prev)
+	{
+		prev = next;
+		next = 0;
+
+
+		for (i = 0; i < tot; ++i)
+		{
+			fbtBuildStruct& cur = strcs[i];
+
+			if (tlens[cur.m_structId] != 0)
+			{
+				FBTsizeType pos;
+				if ((pos = m_missingReport.find(cur.m_name)) != FBT_NPOS)
+					m_missingReport.erase(pos);
+			}
+			else
+			{
+				vptr = cur.m_data.ptr();
+				nrel = cur.m_data.size();
+
+				len     = 0;
+				fake64  = 0;
+				bool hasPtr = false;
+
+				for (e = 0; e < nrel; ++e)
+				{
+					fbtVariable& v = vptr[e];
+					ct = v.m_typeId;
+
+					if (v.m_ptrCount > 0)
+					{
+						hasPtr = true;
+						if (len % FBT_VOID)
+						{
+							fbtERROR( v.m_path.c_str(),
+							          v.m_line, "align %i: %s %s add %i bytes\n", FBT_VOID,
+							          v.m_type.c_str(), v.m_name.c_str(), FBT_VOID - (len % FBT_VOID)
+							        );
+
+							status |= LNK_ALIGNEMENTP;
+						}
+
+						if (fake64 % 8)
+						{
+							fbtERROR( v.m_path.c_str(),
+							          v.m_line, "align %i: %s %s add %i bytes\n", 8,
+							          v.m_type.c_str(), v.m_name.c_str(), 8 - (fake64 % 8)
+							        );
+
+							status |= LNK_ALIGNEMENTP;
+						}
+
+						len += FBT_VOID * v.m_arraySize;
+						fake64 += 8 * v.m_arraySize;
+
+					}
+					else if (tlens[ct])
+					{
+
+						if (ct >= fbt_start)
+						{
+							if (FBT_VOID8 && (len % 8))
+							{
+								fbtERROR(v.m_path.c_str(),
+								         v.m_line, "align: %i alignment error add %i bytes\n",
+								         8,
+								         8 - (len % 8)
+								        );
+								status |= LNK_ALIGNEMENTS;
+							}
+						}
+
+						if (tlens[ct] > 3 && (len % 4))
+						{
+							fbtERROR(cur.m_path.c_str(),
+							         v.m_line,
+							         "align %i: in %s::%s add %i bytes\n",
+							         4,
+							         cur.m_name.c_str(), v.m_name.c_str(), 4 - (len % 4)
+							        );
+							status |= LNK_ALIGNEMENT4;
+						}
+						else if (tlens[ct] == 2 && (len % 2))
+						{
+							fbtERROR(cur.m_path.c_str(),
+							         v.m_line, "align %i: in %s::%s add %i bytes\n",
+							         2,
+							         cur.m_name.c_str(), v.m_name.c_str(), 2 - (len % 2)
+							        );
+							status |= LNK_ALIGNEMENT2;
+						}
+
+						len += tlens[ct] * v.m_arraySize;
+						fake64 += tln64[ct] * v.m_arraySize;
+					}
+					else
+					{
+						next ++;
+						len = 0;
+
+						if (m_missingReport.find(cur.m_name) == FBT_NPOS)
+							m_missingReport.push_back(cur.m_name);
+
+						tln64[cur.m_structId] = 0;
+						tlens[cur.m_structId] = 0;
+
+						break;
+					}
+				}
+
+
+				tln64[cur.m_structId] = fake64;
+				tlens[cur.m_structId] = len;
+
+				if (len != 0)
+				{
+					if (hasPtr || fake64 != len)
+					{
+						if (fake64 % 8)
+						{
+							fbtERROR(cur.m_path.c_str(),
+							         cur.m_line,
+							         "64Bit alignment, in %s add %i bytes\n",
+							         cur.m_name.c_str(), 8 - (fake64 % 8)
+							        );
+							status |= LNK_ALIGNEMENT8;
+						}
+					}
+
+					if (len % 4)
+					{
+						fbtERROR(cur.m_path.c_str(),
+						         cur.m_line,
+						         "align 4: in %s add %i bytes\n",
+						         cur.m_name.c_str(), 4 - (len % 4)
+						        );
+						status |= LNK_ALIGNEMENT4;
+
+					}
+				}
+			}
+		}
+	}
+
+
+	if (!m_missingReport.empty())
+	{
+		status |= LNK_UNDEFINED_TYPES;
+
+		fbtStringPtrArray::Iterator it = m_missingReport.iterator();
+		while (it.hasMoreElements())
+		{
+			fbtId& id = it.getNext();
+			fbtPrintf("Link error: undefined reference to type '%s'\n", id.c_str());
+		}
+	}
+
+	if (fbtDEBUG >= 3)
+	{
+		fbtBuildStructs::Iterator bit = struct_builders.iterator();
+
+		while (bit.hasMoreElements())
+		{
+			fbtBuildStruct& bs = bit.getNext();
+
+			fbtTRACE(bs.m_path.c_str(), bs.m_line, "typeid (%s):%i\n", bs.m_name.c_str(), bs.m_structId);
+			if (fbtDEBUG > 0 && !bs.m_data.empty())
+			{
+				fbtVariables::Iterator it = bs.m_data.iterator();
+				while (it.hasMoreElements())
+				{
+					fbtVariable& cvar = it.getNext();
+					fbtTRACE(cvar.m_path.c_str(), cvar.m_line, "typeid:%-8inameid:%-8isizeof:%-8i%s %s\n",
+					         cvar.m_typeId, cvar.m_nameId,
+					         (cvar.m_ptrCount > 0 ? FBT_VOID : tlens[cvar.m_typeId]) * cvar.m_arraySize,
+					         cvar.m_type.c_str(),
+					         cvar.m_name.c_str()
+					        );
+				}
+			}
+		}
+	}
+
+	return status;
+}
Index: extern/FileTools/File/fbtBuilder.h
===================================================================
--- extern/FileTools/File/fbtBuilder.h	(revisione 0)
+++ extern/FileTools/File/fbtBuilder.h	(revisione 0)
@@ -0,0 +1,171 @@
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Tables).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+#ifndef _fbtBuilder_h_
+#define _fbtBuilder_h_
+
+#include "fbtTypes.h"
+#include "fbtTables.h"
+
+/** \addtogroup FBT
+*  @{
+*/
+
+typedef fbtFixedString<272>         fbtPath;
+typedef fbtFixedString<fbtMaxID>    fbtId;
+typedef int                         fbtArraySlots[FBT_ARRAY_SLOTS];
+typedef void*                       fbtParser;
+typedef fbtArray<fbtId>             fbtStringPtrArray;
+typedef fbtArray<fbtPath>           fbtPathArray;
+
+class fbtVariable
+{
+public:
+
+	fbtVariable()
+		:   m_type(), 
+			m_name(), 
+			m_typeId(-1),
+		    m_nameId(-1), 
+			m_ptrCount(0), 
+			m_numSlots(0),
+		    m_isFptr(0), 
+			m_lstat(0), 
+			m_undefined(0),
+		    m_isDependentType(false), 
+			m_arraySize(1),
+			m_path(),
+			m_line(-1)
+	{
+	}
+
+	fbtId   m_type;
+	fbtId   m_name;
+	int     m_typeId;
+	int     m_nameId;
+	int     m_ptrCount;
+	int     m_numSlots;
+	int     m_isFptr;
+	int     m_lstat;
+	int     m_undefined;
+	bool    m_isDependentType;
+
+
+	fbtArraySlots m_arrays;
+	FBTsize m_arraySize;
+
+	fbtPath         m_path;
+	FBTsize         m_line;
+
+
+
+};
+
+typedef fbtArray<fbtVariable> fbtVariables;
+
+
+class fbtBuildStruct
+{
+public:
+
+	fbtBuildStruct()
+		:   m_structId(-1),
+		    m_line(-1),
+		    m_nrDependentTypes(0)
+	{
+	}
+
+	FBTsize         m_structId;
+	fbtId           m_name;
+	fbtVariables    m_data;
+	FBTsize         m_nrDependentTypes;
+	fbtPath         m_path;
+	FBTsize         m_line;
+
+};
+
+typedef fbtArray<fbtBuildStruct> fbtBuildStructs;
+
+
+
+enum fbtLinkerIssues
+{
+
+	LNK_OK              = 0,
+	LNK_ASSERT          = (1 << 0),
+	LNK_ALIGNEMENT2     = (1 << 1),
+	LNK_ALIGNEMENT4     = (1 << 2),
+	LNK_ALIGNEMENT8     = (1 << 3),
+	LNK_ALIGNEMENTS     = (1 << 4),
+	LNK_ALIGNEMENTP     = (1 << 5),
+	LNK_UNKNOWN         = (1 << 6),
+	LNK_UNDEFINED_TYPES = (1 << 7),
+	LNK_DUPLICATE_TYPES = (1 << 8)
+};
+
+
+class fbtBuilder
+{
+public:
+
+	fbtBuilder();
+	~fbtBuilder();
+
+	int parseFile(const fbtPath& id);
+	int parseBuffer(const fbtId& name, const char* ms);
+
+	int buildTypes(void);
+
+	void writeFile(const fbtId& id, class fbtStream* fp);
+	void writeFile(const fbtId& id, const fbtPath& path);
+	void writeStream(class fbtStream* fp);
+
+	fbtBinTables* write(void);
+
+private:
+
+	int doParse(void);
+	class fbtBuildInfo* m_build;
+
+	void writeBinPtr(fbtStream* fp, void* ptr, int len);
+	void writeCharPtr(fbtStream* fp, const fbtStringPtrArray& ptrs);
+
+	void writeValidationProgram(const fbtPath& path);
+
+
+	void makeName(fbtVariable&, bool);
+
+	FBTsize           fbt_start;
+	fbtPathArray      fbt_includes;
+	fbtStringPtrArray fbt_namespaces, fbt_skip;
+
+	fbtBuildStructs fbt_struct_builders;
+	int m_curBuf, m_writeMode;
+
+};
+
+/** @}*/
+
+#endif//_fbtBuilder_h_
Index: extern/FileTools/File/fbtConfig.h
===================================================================
--- extern/FileTools/File/fbtConfig.h	(revisione 0)
+++ extern/FileTools/File/fbtConfig.h	(revisione 0)
@@ -0,0 +1,46 @@
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Tables).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+#ifndef _fbtConfig_h_
+#define _fbtConfig_h_
+
+
+/** \addtogroup FBT
+*  @{
+*/
+
+// global config settings
+
+#define fbtDEBUG        1           // Traceback detail
+#define fbtMaxTable     5000        // Maximum number of elements in a table
+#define fbtMaxID        64          // Maximum character array length
+#define fbtMaxMember    256         // Maximum number of members in a struct or class.
+#define fbtDefaultAlloc 2048        // Table default allocation size
+#define FBT_TYPE_LEN_VALIDATE   1   // Write a validation file (use MakeFBT.cmake->ADD_FBT_VALIDATOR to add a self validating build)
+#define FBT_ARRAY_SLOTS         2   // Maximum dimensional array, eg: (int m_member[..][..] -> [FBT_ARRAY_SLOTS])
+
+/** @}*/
+
+#endif//_fbtConfig_h_
Index: extern/FileTools/File/fbtFile.cpp
===================================================================
--- extern/FileTools/File/fbtFile.cpp	(revisione 0)
+++ extern/FileTools/File/fbtFile.cpp	(revisione 0)
@@ -0,0 +1,1029 @@
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Tables).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+#define FBT_IN_SOURCE
+
+#include "fbtFile.h"
+#include "fbtStreams.h"
+#include "fbtTables.h"
+#include "fbtPlatformHeaders.h"
+
+// Common Identifiers
+const FBTuint32 ENDB = FBT_ID('E', 'N', 'D', 'B');
+const FBTuint32 DNA1 = FBT_ID('D', 'N', 'A', '1');
+const FBTuint32 DATA = FBT_ID('D', 'A', 'T', 'A');
+const FBTuint32 SDNA = FBT_ID('S', 'D', 'N', 'A');
+
+
+// Compile asserts
+FBT_ASSERTCOMP(ChunkLen32, sizeof(fbtFile::Chunk32) == 20);
+FBT_ASSERTCOMP(ChunkLen64, sizeof(fbtFile::Chunk64) == 24);
+
+#if FBT_ARCH == FBT_ARCH_32
+FBT_ASSERTCOMP(ChunkLenNative, sizeof(fbtFile::Chunk32) == sizeof(fbtFile::Chunk));
+#else
+FBT_ASSERTCOMP(ChunkLenNative, sizeof(fbtFile::Chunk64) == sizeof(fbtFile::Chunk));
+#endif
+
+#define FBT_MALLOC_FAILED   fbtPrintf("Failed to allocate memory!\n");
+#define FBT_INVALID_READ    fbtPrintf("Invalid read!\n");
+#define FBT_INVALID_LEN     fbtPrintf("Invalid block length!\n");
+#define FBT_INVALID_INS     fbtPrintf("Table insertion failed!\n");
+#define FBT_LINK_FAILED     fbtPrintf("Linking failed!\n");
+
+
+struct fbtChunk
+{
+	enum Size
+	{
+		BlockSize   = sizeof (fbtFile::Chunk),
+		Block32     = sizeof (fbtFile::Chunk32),
+		Block64     = sizeof (fbtFile::Chunk64),
+	};
+
+	static int read(fbtFile::Chunk* dest, fbtStream* stream, int flags);
+	static int write(fbtFile::Chunk* src, fbtStream* stream);
+};
+
+
+
+
+fbtFile::fbtFile(const char* uid)
+	:   m_version(-1), m_fileVersion(0), m_fileHeader(0), m_uhid(uid), m_aluhid(0),
+	    m_memory(0), m_file(0), m_curFile(0)
+{
+}
+
+
+fbtFile::~fbtFile()
+{
+	if (m_curFile)
+		fbtFree(m_curFile);
+	m_curFile = 0;
+
+	MemoryChunk* node = (MemoryChunk*)m_chunks.first, *tnd;
+	while (node)
+	{
+		fbtFree(node->m_block);
+		fbtFree(node->m_newBlock);
+
+		tnd  = node;
+		node = node->m_next;
+
+		fbtFree(tnd);
+	}
+
+	delete m_file;
+	delete m_memory;
+}
+
+
+
+int fbtFile::parse(const char* path, int mode)
+{
+	fbtStream* stream = 0;
+
+	if (mode == PM_UNCOMPRESSED || mode == PM_COMPRESSED)
+	{
+#if FBT_USE_GZ_FILE == 1
+		if (mode == PM_COMPRESSED)
+			stream = new fbtGzStream();
+		else
+#endif
+		{
+			stream = new fbtFileStream();
+		}
+
+		stream->open(path, fbtStream::SM_READ);
+	}
+	else
+	{
+		stream = new fbtMemoryStream();
+		stream->open(path, fbtStream::SM_READ);
+	}
+
+	if (!stream->isOpen())
+	{
+		fbtPrintf("File '%s' loading failed\n", path);
+		return FS_FAILED;
+	}
+
+	if (m_curFile)
+		fbtFree(m_curFile);
+
+
+	FBTsize pl = strlen(path);
+
+	m_curFile = (char*)fbtMalloc(pl + 1);
+	if (m_curFile)
+	{
+		fbtMemcpy(m_curFile, path, pl);
+		m_curFile[pl] = 0;
+	}
+
+	int result = parseStreamImpl(stream);
+	delete stream;
+	return result;
+}
+
+
+
+int fbtFile::parse(const void* memory, FBTsize sizeInBytes, int mode)
+{
+	fbtMemoryStream ms;
+	ms.open( memory, sizeInBytes, fbtStream::SM_READ );
+
+	if (!ms.isOpen())
+	{
+		fbtPrintf("Memory %p(%i) loading failed\n", memory, sizeInBytes);
+		return FS_FAILED;
+	}
+
+	return parseStreamImpl(&ms);
+}
+
+
+
+int fbtFile::parseHeader(fbtStream* stream)
+{
+	m_header.resize(12);
+	stream->read(m_header.ptr(), 12);
+
+	if (!fbtCharNEq(m_header.c_str(), m_uhid, 7) && !fbtCharNEq(m_header.c_str(), m_aluhid, 7))
+	{
+		fbtPrintf("Unknown header ID '%s'\n", m_header.c_str());
+		return FS_INV_HEADER_STR;
+	}
+
+	char* headerMagic = (m_header.ptr() + 7);
+
+	m_fileHeader = 0;
+	m_fileVersion = 0;
+
+	if (*(headerMagic++) == FM_64_BIT)
+	{
+		m_fileHeader |= FH_CHUNK_64;
+		if (FBT_VOID4)
+			m_fileHeader |= FH_VAR_BITS;
+	}
+	else if (FBT_VOID8)
+		m_fileHeader |= FH_VAR_BITS;
+
+
+	if (*(headerMagic++) == FM_BIG_ENDIAN)
+	{
+		if (FBT_ENDIAN_IS_LITTLE)
+			m_fileHeader |= FH_ENDIAN_SWAP;
+	}
+	else if (FBT_ENDIAN_IS_BIG)
+		m_fileHeader |= FH_ENDIAN_SWAP;
+
+
+	m_fileVersion = atoi(headerMagic);
+
+	return FS_OK;
+}
+
+
+int fbtFile::parseStreamImpl(fbtStream* stream)
+{
+	int status;
+
+	status = parseHeader(stream);
+	if (status != FS_OK)
+	{
+		fbtPrintf("Failed to extract header!\n");
+		return status;
+	}
+
+	if (!m_memory)
+	{
+		m_memory = new fbtBinTables();
+
+		status = initializeTables(m_memory);
+		if (status != FS_OK)
+		{
+			fbtPrintf("Failed to initialize builtin tables\n");
+			return status;
+		}
+	}
+
+
+	if (m_file)
+	{
+		delete m_file;
+		m_file = 0;
+	}
+
+
+	// preallocate table
+	m_map.reserve(fbtDefaultAlloc);
+
+
+	Chunk chunk;
+
+
+	// Scan chunks
+
+	do
+	{
+		if ((status = fbtChunk::read(&chunk, stream, m_fileHeader)) <= 0)
+		{
+			FBT_INVALID_READ;
+			return FS_INV_READ;
+		}
+
+
+		if (chunk.m_code == SDNA)
+		{
+			chunk.m_code = DNA1;
+			stream->seek(-status, SEEK_CUR);
+			chunk.m_len = stream->size() - stream->position();
+		}
+
+		// exit on end byte
+		if (chunk.m_code == ENDB)
+			break;
+
+
+		void* curPtr = fbtMalloc(chunk.m_len);
+		if (!curPtr)
+		{
+			FBT_MALLOC_FAILED;
+			return FS_BAD_ALLOC;
+		}
+
+		if (stream->read(curPtr, chunk.m_len) <= 0)
+		{
+			FBT_INVALID_READ;
+			return FS_INV_READ;
+		}
+
+		if (chunk.m_code == DNA1)
+		{
+			m_file = new fbtBinTables(curPtr, chunk.m_len);
+			m_file->m_ptr = m_fileHeader & FH_CHUNK_64 ? 8 : 4;
+
+
+			if (!m_file->read((m_fileHeader & FH_ENDIAN_SWAP) != 0))
+			{
+				fbtPrintf("Failed to initialize tables\n");
+				return FS_INV_READ;
+			}
+
+			compileOffsets();
+
+			if ((status = link()) != FS_OK)
+			{
+				FBT_LINK_FAILED;
+				return FS_LINK_FAILED;
+			}
+			break;
+		}
+		else
+		{
+#if FBT_ASSERT_INSERT
+			FBTsizeType pos;
+			if ((pos = m_map.find(chunk.m_old)) != FBT_NPOS)
+			{
+				fbtFree(curPtr);
+				int result = fbtMemcmp(&m_map.at(pos)->m_chunk, &chunk, fbtChunk::BlockSize);
+				if (result != 0)
+				{
+					FBT_INVALID_READ;
+					return FS_INV_READ;
+				}
+			}
+#else
+			if (m_map.find(chunk.m_old) != FBT_NPOS)
+			{
+				fbtFree(curPtr);
+			}
+#endif
+			else
+			{
+				MemoryChunk* bin = static_cast<MemoryChunk*>(fbtMalloc(sizeof(MemoryChunk)));
+				if (!bin)
+				{
+					FBT_MALLOC_FAILED;
+					return FS_BAD_ALLOC;
+				}
+				fbtMemset(bin, 0, sizeof(MemoryChunk));
+				bin->m_block = curPtr;
+
+				Chunk* cp    = &bin->m_chunk;
+				cp->m_code   = chunk.m_code;
+				cp->m_len    = chunk.m_len;
+				cp->m_nr     = chunk.m_nr;
+				cp->m_typeid = chunk.m_typeid;
+				cp->m_old    = chunk.m_old;
+				m_chunks.push_back(bin);
+
+				if (m_map.insert(bin->m_chunk.m_old, bin) == false)
+				{
+					FBT_INVALID_INS;
+					return FS_INV_INSERT;
+				}
+			}
+		}
+	}
+	while (!stream->eof());
+	return status;
+}
+
+
+class fbtPrimType
+{
+public:
+
+};
+
+class fbtLinkCompiler
+{
+public:
+	fbtBinTables* m_mp;
+	fbtBinTables* m_fp;
+
+	fbtStruct* find(const fbtCharHashKey& kvp);
+	fbtStruct* find(fbtStruct* strc, fbtStruct* member, bool isPointer, bool& needCast);
+	int        link(void);
+};
+
+
+
+fbtStruct* fbtLinkCompiler::find(const fbtCharHashKey& kvp)
+{
+	FBTtype i;
+	if ( (i = m_fp->findTypeId(kvp)) != ((FBTtype)-1))
+		return m_fp->m_offs.at(i);
+	return 0;
+}
+
+
+fbtStruct* fbtLinkCompiler::find(fbtStruct* strc, fbtStruct* member, bool isPointer, bool& needCast)
+{
+	fbtStruct::Members::Pointer md = strc->m_members.ptr();
+	FBTsizeType i, s = strc->m_members.size();
+
+	FBTuint32 k1 = member->m_val.k32[0];
+
+	for (i = 0; i < s; i++)
+	{
+		fbtStruct* strc2 = &md[i];
+
+		if (strc2->m_nr == member->m_nr && strc2->m_dp ==  member->m_dp)
+		{
+			if (strc2->m_val.k32[1] == member->m_val.k32[1]) //base name
+			{				
+				if (!strc2->m_keyChain.equal(member->m_keyChain))
+					continue;
+
+				FBTuint32 k2 = strc2->m_val.k32[0];
+				if (k1 == k2)
+					return strc2;
+
+				if (isPointer)
+					continue;
+
+				if (fbtIsIntType(k1) && fbtIsIntType(k2))
+					return strc2;
+
+				if (fbtIsNumberType(k1) && fbtIsNumberType(k2))
+				{
+					needCast = true;
+					return strc2;
+				}
+			}
+		}
+	}
+
+
+	return 0;
+}
+
+int fbtLinkCompiler::link(void)
+{
+	fbtBinTables::OffsM::Pointer md = m_mp->m_offs.ptr();
+	fbtBinTables::OffsM::Pointer fd = m_fp->m_offs.ptr();
+
+	FBTsizeType i, i2; 
+	fbtStruct::Members::Pointer p2;
+
+
+	for (i = 0; i < m_mp->m_offs.size(); ++i)
+	{
+		fbtStruct* strc = md[i];
+		strc->m_link = find(m_mp->m_type[strc->m_key.k16[0]].m_name);
+
+		if (strc->m_link)
+			strc->m_link->m_link = strc;
+
+		p2 = strc->m_members.ptr();
+
+		//fbtPrintf("+%-3d %s\n", i, m_mp->getStructType(strc));
+		for (i2 = 0; i2 < strc->m_members.size(); ++i2)
+		{
+			fbtStruct* member = &strc->m_members[i2];
+			//fbtPrintf("  %3d %s %s\n", i2, m_mp->getStructType(strc2), m_mp->getStructName(strc2));
+
+			FBT_ASSERT(!member->m_link);
+			member->m_flag |= strc->m_link ? 0 : fbtStruct::MISSING;
+
+			if (!(member->m_flag & fbtStruct::MISSING))
+			{
+				FBT_ASSERT(member->m_key.k16[1] < m_mp->m_nameNr);
+				bool isPointer = m_mp->m_name[member->m_key.k16[1]].m_ptrCount > 0;
+				bool needCast = false;
+				member->m_link = find(strc->m_link, member, isPointer, needCast);
+				if (member->m_link)
+				{
+					member->m_link->m_link = member;
+					if (needCast)
+					{
+						member->m_flag |= fbtStruct::NEED_CAST;
+						member->m_link->m_flag |= fbtStruct::NEED_CAST;
+					}
+				}
+			}
+		}
+
+	}
+
+	return fbtFile::FS_OK;
+}
+
+void castValue(FBTsize* srcPtr, FBTsize* dstPtr, FBT_PRIM_TYPE srctp, FBT_PRIM_TYPE dsttp, FBTsize malen)
+{
+#define GET_V(value, current, type, cast, ptr, match) \
+	if (current == type) \
+	{ \
+		value = (*(cast*)ptr); \
+		ptr += sizeof(cast); \
+		if (++match >= 2) continue; \
+	}
+
+#define SET_V(value, current, type, cast, ptr, match) \
+	if (current == type) \
+	{ \
+		(*(cast*)ptr) = (cast)value; \
+		ptr += sizeof(cast); \
+		if (++match >= 2) continue; \
+	}
+
+	double value = 0.0;
+
+	FBTsizeType i;
+	for (i = 0; i < malen; i++)
+	{
+		int match = 0;
+		GET_V(value, srctp, FBT_PRIM_CHAR,    char,            srcPtr, match);
+		SET_V(value, dsttp, FBT_PRIM_CHAR,    char,            dstPtr, match);
+		GET_V(value, srctp, FBT_PRIM_SHORT,   short,           srcPtr, match);
+		SET_V(value, dsttp, FBT_PRIM_SHORT,   short,           dstPtr, match);
+		GET_V(value, srctp, FBT_PRIM_USHORT,  unsigned short,  srcPtr, match);
+		SET_V(value, dsttp, FBT_PRIM_USHORT,  unsigned short,  dstPtr, match);
+		GET_V(value, srctp, FBT_PRIM_INT,     int,             srcPtr, match);
+		SET_V(value, dsttp, FBT_PRIM_INT,     int,             dstPtr, match);
+		GET_V(value, srctp, FBT_PRIM_LONG,    int,             srcPtr, match);
+		SET_V(value, dsttp, FBT_PRIM_LONG,    int,             dstPtr, match);
+		GET_V(value, srctp, FBT_PRIM_FLOAT,   float,           srcPtr, match);
+		SET_V(value, dsttp, FBT_PRIM_FLOAT,   float,           dstPtr, match);
+		GET_V(value, srctp, FBT_PRIM_DOUBLE,  double,          srcPtr, match);
+		SET_V(value, dsttp, FBT_PRIM_DOUBLE,  double,          dstPtr, match);
+	}
+#undef GET_V
+#undef SET_V
+}
+
+
+int fbtFile::link(void)
+{
+	fbtBinTables::OffsM::Pointer md = m_memory->m_offs.ptr();
+	fbtBinTables::OffsM::Pointer fd = m_file->m_offs.ptr();
+	FBTsizeType s2, i2, a2, n;
+	fbtStruct::Members::Pointer p2;
+	FBTsize mlen, malen, total, pi;
+
+	char* dst, *src;
+	FBTsize* dstPtr, *srcPtr;
+
+	bool needSwap = (m_fileHeader & FH_ENDIAN_SWAP) != 0;
+
+	FBThash hk = fbtCharHashKey("Link").hash();
+
+
+	MemoryChunk* node;
+	for (node = (MemoryChunk*)m_chunks.first; node; node = node->m_next)
+	{
+		if (node->m_chunk.m_typeid > m_file->m_strcNr || !( fd[node->m_chunk.m_typeid]->m_link))
+			continue;
+
+		fbtStruct* fs, *ms;
+		fs = fd[node->m_chunk.m_typeid];
+		ms = fs->m_link;
+
+		node->m_newTypeId = ms->m_strcId;
+
+		if (m_memory->m_type[ms->m_key.k16[0]].m_typeId == hk)
+		{
+			FBTsize totSize = node->m_chunk.m_len;
+			node->m_newBlock = fbtMalloc(totSize);
+			if (!node->m_newBlock)
+			{
+				FBT_MALLOC_FAILED;
+				return FS_BAD_ALLOC;
+			}
+
+			fbtMemcpy(node->m_newBlock, node->m_block, totSize);
+			continue;
+		}
+
+
+		if (skip(m_memory->m_type[ms->m_key.k16[0]].m_typeId))
+			continue;
+
+
+		FBTsize totSize = (node->m_chunk.m_nr * ms->m_len);
+
+		node->m_chunk.m_len = totSize;
+
+
+		node->m_newBlock = fbtMalloc(totSize);
+		if (!node->m_newBlock)
+		{
+			FBT_MALLOC_FAILED;
+			return FS_BAD_ALLOC;
+		}
+
+
+
+		// always zero this
+		fbtMemset(node->m_newBlock, 0, totSize);
+	}
+
+
+
+	FBTuint8 mps = m_memory->m_ptr, fps = m_file->m_ptr;
+
+	for (node = (MemoryChunk*)m_chunks.first; node; node = node->m_next)
+	{
+		if (node->m_newTypeId > m_memory->m_strcNr)
+			continue;
+
+
+
+		fbtStruct* cs = md[node->m_newTypeId];
+		if (m_memory->m_type[cs->m_key.k16[0]].m_typeId == hk)
+			continue;
+
+		if (!cs->m_link || skip(m_memory->m_type[cs->m_key.k16[0]].m_typeId) || !node->m_newBlock)
+		{
+			fbtFree(node->m_newBlock);
+			node->m_newBlock = 0;
+
+			continue;
+		}
+
+		s2 = cs->m_members.size();
+		p2 = cs->m_members.ptr();
+
+		for (n = 0; n < node->m_chunk.m_nr; ++n)
+		{
+			dst = static_cast<char*>(node->m_newBlock) + (cs->m_len * n);
+			src = static_cast<char*>(node->m_block) + (cs->m_link->m_len * n);
+
+
+			for (i2 = 0; i2 < s2; ++i2)
+			{
+				fbtStruct* dstStrc = &p2[i2];
+				fbtStruct* srcStrc = dstStrc->m_link;
+
+				// If it's missing we can safely skip this block
+				if (!srcStrc)
+					continue;
+
+
+				dstPtr = reinterpret_cast<FBTsize*>(dst + dstStrc->m_off);
+				srcPtr = reinterpret_cast<FBTsize*>(src + srcStrc->m_off);
+
+
+
+				const fbtName& nameD = m_memory->m_name[dstStrc->m_key.k16[1]];
+				const fbtName& nameS = m_file->m_name[srcStrc->m_key.k16[1]];
+
+
+
+				// Take the minimum length of any array.
+				mlen = dstStrc->m_len > srcStrc->m_len ? srcStrc->m_len : dstStrc->m_len;
+
+
+				if (nameD.m_ptrCount > 0)
+				{
+					if ((*srcPtr))
+					{
+						if (nameD.m_ptrCount  > 1)
+						{
+							MemoryChunk* bin = findBlock((FBTsize)(*srcPtr));
+							if (bin)
+							{
+								if (bin->m_flag & MemoryChunk::BLK_MODIFIED)
+									(*dstPtr) = (FBTsize)bin->m_newBlock;
+								else
+								{
+									// take pointer size out of the equation
+									total = bin->m_chunk.m_len / fps;
+
+
+									FBTsize* nptr = (FBTsize*)fbtMalloc(total * mps);
+									fbtMemset(nptr, 0, total * mps);
+
+									// always use 32 bit, then offset + 2 for 64 bit (Old pointers are sorted in this mannor)
+									FBTuint32* optr = (FBTuint32*)bin->m_block;
+
+
+									for (pi = 0; pi < total; pi++, optr += (fps == 4 ? 1 : 2))
+										nptr[pi] = (FBTsize)findPtr((FBTsize) * optr);
+
+									(*dstPtr) = (FBTsize)(nptr);
+
+									bin->m_chunk.m_len = total * mps;
+									bin->m_flag |= MemoryChunk::BLK_MODIFIED;
+
+									fbtFree(bin->m_newBlock);
+									bin->m_newBlock = nptr;
+								}
+							}
+							else
+							{
+								//fbtPrintf("**block not found @ 0x%p)\n", src);
+							}
+						}
+						else
+						{
+							malen = nameD.m_arraySize > nameS.m_arraySize ? nameS.m_arraySize : nameD.m_arraySize;
+
+							FBTsize* dptr = (FBTsize*)dstPtr;
+
+							// always use 32 bit, then offset + 2 for 64 bit (Old pointers are sorted in this mannor)
+							FBTuint32* sptr = (FBTuint32*)srcPtr;
+
+
+							for (a2 = 0; a2 < malen; ++a2, sptr += (fps == 4 ? 1 : 2))
+								dptr[a2] = (FBTsize)findPtr((FBTsize) * sptr);
+						}
+					}
+				}
+				else
+				{
+					bool needCast = (dstStrc->m_flag & fbtStruct::NEED_CAST) != 0;
+
+					FBTsize* tmpPtr = dstPtr;
+					FBTsize  tmpLen = mlen;
+					FBTsize  tmpALen = 0;
+					FBT_PRIM_TYPE stp = FBT_PRIM_UNKNOWN, dtp  = FBT_PRIM_UNKNOWN;
+
+					if (needCast || needSwap)
+					{
+						stp = fbtGetPrimType(srcStrc->m_val.k32[0]);
+						dtp = fbtGetPrimType(dstStrc->m_val.k32[0]);
+
+						FBT_ASSERT(fbtIsNumberType(stp) && fbtIsNumberType(dtp) && stp != dtp);
+					}
+
+					if (needCast)
+					{
+						//printf("need cast: %s %s\n", m_memory->getStructName(dstStrc), m_memory->getStructType(dstStrc));
+						tmpLen = srcStrc->m_len;
+						tmpPtr = (FBTsize*)fbtMalloc(tmpLen);						
+					}
+
+					fbtMemcpy(tmpPtr, srcPtr, tmpLen);
+
+					if (needSwap)
+					{
+						char* cp = (char*)tmpPtr;
+
+						malen = nameD.m_arraySize > nameS.m_arraySize ? nameS.m_arraySize : nameD.m_arraySize;
+						tmpALen = needCast ? nameS.m_arraySize : malen;	
+
+						if (stp == FBT_PRIM_SHORT || stp == FBT_PRIM_USHORT) 
+							fbtSwap16((FBTuint16*)cp, tmpALen);							
+						else if (stp >= FBT_PRIM_INT && stp <= FBT_PRIM_FLOAT) 
+							fbtSwap32((FBTuint32*)cp, tmpALen);
+						else if (stp == FBT_PRIM_DOUBLE)
+							fbtSwap64((FBTuint64*)cp, tmpALen);
+					}
+					
+					if (needCast)
+					{						
+						castValue(srcPtr, dstPtr, stp, dtp, malen);
+
+						fbtFree(tmpPtr);
+						tmpPtr = 0;
+					}
+				}
+			}
+		}
+
+		notifyData(node->m_newBlock, node->m_chunk);
+	}
+
+
+
+	for (node = (MemoryChunk*)m_chunks.first; node; node = node->m_next)
+	{
+		if (node->m_block)
+		{
+			fbtFree(node->m_block);
+			node->m_block = 0;
+		}
+	}
+
+	return fbtFile::FS_OK;
+}
+
+
+
+
+void* fbtFile::findPtr(const FBTsize& iptr)
+{
+	FBTsizeType i;
+	if ((i = m_map.find(iptr)) != FBT_NPOS)
+		return m_map.at(i)->m_newBlock;
+	return 0;
+}
+
+
+fbtFile::MemoryChunk* fbtFile::findBlock(const FBTsize& iptr)
+{
+	FBTsizeType i;
+	if ((i = m_map.find(iptr)) != FBT_NPOS)
+		return m_map.at(i);
+	return 0;
+}
+
+
+
+int fbtFile::compileOffsets(void)
+{
+	fbtLinkCompiler lnk;
+	lnk.m_mp = m_memory;
+	lnk.m_fp = m_file;
+	return lnk.link();
+}
+
+bool fbtFile::_setuid(const char* uid)
+{
+	if (!uid || strlen(uid) != 7) return false;
+
+	m_uhid = uid;
+	return true;
+}
+
+int fbtFile::reflect(const char* path, const int mode, const fbtEndian& endian)
+{
+	fbtStream* fs;
+	
+#if FBT_USE_GZ_FILE == 1
+	if (mode == PM_COMPRESSED)
+		fs = new fbtGzStream();
+	else
+#endif
+	{
+		fs = new fbtFileStream();
+	}
+	
+	fs->open(path, fbtStream::SM_WRITE);
+
+
+	FBTuint8 cp = FBT_VOID8 ? FM_64_BIT : FM_32_BIT;
+	FBTuint8 ce = ((FBTuint8)fbtGetEndian()) == FBT_ENDIAN_IS_BIG ? FM_BIG_ENDIAN : FM_LITTLE_ENDIAN;
+
+//	Commented for now since the rest of the code does not care
+//	if (endian != FBT_ENDIAN_NATIVE)
+//	{
+//		if (endian == FBT_ENDIAN_IS_BIG)
+//			ce = FM_BIG_ENDIAN;
+//		else
+//			ce = FM_LITTLE_ENDIAN;
+//	}
+
+	// put magic
+	//fs->writef("%s%c%c%i", m_uhid, cp, ce, m_version);
+	char header[12] = {0,0,0,0,0,0,0,0,0,0,0,0};
+	char version[33];
+	sprintf(version, "%i",m_version);
+	
+	strncpy(&header[0], m_uhid, 7); // 7 first bytes of header
+	header[7] = cp;					// 8th byte = pointer size
+	header[8] = ce;					// 9th byte = endianness
+	strncpy(&header[9], version, 3);// last 3 bytes vor 3 version char
+	
+	fs->write(header, 12);
+	
+	writeData(fs);
+
+	// write DNA1
+	Chunk ch;
+	ch.m_code   = DNA1;
+	ch.m_len    = getFBTlength();
+	ch.m_nr     = 1;
+	ch.m_old    = 0;
+	ch.m_typeid = 0;
+	fs->write(&ch, fbtChunk::BlockSize);
+	fs->write(getFBT(), ch.m_len);
+
+
+	// write ENDB (End Byte | EOF )
+	ch.m_code   = ENDB;
+	ch.m_len    = 0;
+	ch.m_nr     = 0;
+	ch.m_old    = 0;
+	ch.m_typeid = 0;
+	fs->write(&ch, fbtChunk::BlockSize);
+	
+	delete fs;
+	return FS_OK;
+
+}
+
+void fbtFile::writeStruct(fbtStream* stream, FBTtype index, FBTuint32 code, FBTsize len, void* writeData)
+{
+	Chunk ch;
+	ch.m_code   = code;
+	ch.m_len    = len;
+	ch.m_nr     = 1;
+	ch.m_old    = (FBTsize)writeData;
+	ch.m_typeid = index;
+
+	fbtChunk::write(&ch, stream);
+}
+
+void fbtFile::writeBuffer(fbtStream* stream, FBTsize len, void* writeData)
+{
+	Chunk ch;
+	ch.m_code   = DATA;
+	ch.m_len    = len;
+	ch.m_nr     = 1;
+	ch.m_old    = (FBTsize)writeData;
+	ch.m_typeid = m_memory->findTypeId("Link");
+
+	fbtChunk::write(&ch, stream);
+}
+
+int fbtChunk::write(fbtFile::Chunk* src, fbtStream* stream)
+{	
+	int size = 0;
+	size += stream->write(src, BlockSize);
+	size += stream->write((void*)src->m_old, src->m_len);
+	return size;
+}
+
+int fbtChunk::read(fbtFile::Chunk* dest, fbtStream* stream, int flags)
+{
+	int bytesRead = 0;
+	bool bitsVary   = (flags & fbtFile::FH_VAR_BITS) != 0;
+	bool swapEndian = (flags & fbtFile::FH_ENDIAN_SWAP) != 0;
+
+	fbtFile::Chunk64 c64;
+	fbtFile::Chunk32 c32;
+	fbtFile::Chunk*  cpy;
+
+
+	if (FBT_VOID8)
+	{
+
+		if (bitsVary)
+		{
+			fbtFile::Chunk32 src;
+			if ((bytesRead = stream->read(&src, Block32)) <= 0)
+			{
+				FBT_INVALID_READ;
+				return fbtFile::FS_INV_READ;
+			}
+
+			c64.m_code    = src.m_code;
+			c64.m_len     = src.m_len;
+
+			union
+			{
+				FBTuint64   m_ptr;
+				FBTuint32   m_doublePtr[2];
+			} ptr;
+			ptr.m_doublePtr[0] = src.m_old;
+			ptr.m_doublePtr[1] = 0;
+
+			c64.m_old     = ptr.m_ptr;
+			c64.m_typeid  = src.m_typeid;
+			c64.m_nr      = src.m_nr;
+		}
+		else
+		{
+			if ((bytesRead = stream->read(&c64, BlockSize)) <= 0)
+			{
+				FBT_INVALID_READ;
+				return fbtFile::FS_INV_READ;
+			}
+		}
+
+
+		if (swapEndian)
+		{
+			if ((c64.m_code & 0xFFFF) == 0)
+				c64.m_code >>= 16;
+
+			c64.m_len    = fbtSwap32(c64.m_len);
+			c64.m_nr     = fbtSwap32(c64.m_nr);
+			c64.m_typeid = fbtSwap32(c64.m_typeid);
+		}
+
+
+
+		cpy = (fbtFile::Chunk*)(&c64);
+	}
+	else
+	{
+
+		if (bitsVary)
+		{
+			fbtFile::Chunk64 src;
+			if ((bytesRead = stream->read(&src, Block64)) <= 0)
+			{
+				FBT_INVALID_READ;
+				return fbtFile::FS_INV_READ;
+			}
+
+			// copy down
+
+			c32.m_code    = src.m_code;
+			c32.m_len     = src.m_len;
+
+			union
+			{
+				FBTuint64   m_ptr;
+				FBTuint32   m_doublePtr[2];
+			} ptr;
+			ptr.m_doublePtr[0] = 0;
+			ptr.m_doublePtr[1] = 0;
+			ptr.m_ptr = src.m_old;
+
+			c32.m_old       = ptr.m_doublePtr[0] != 0 ? ptr.m_doublePtr[0] : ptr.m_doublePtr[1];
+			c32.m_typeid    = src.m_typeid;
+			c32.m_nr        = src.m_nr;
+		}
+		else
+		{
+			if ((bytesRead = stream->read(&c32, BlockSize)) <= 0)
+			{
+				FBT_INVALID_READ;
+				return fbtFile::FS_INV_READ;
+			}
+		}
+
+
+		if (swapEndian)
+		{
+			if ((c32.m_code & 0xFFFF) == 0)
+				c32.m_code >>= 16;
+
+			c32.m_len    = fbtSwap32(c32.m_len);
+			c32.m_nr     = fbtSwap32(c32.m_nr);
+			c32.m_typeid = fbtSwap32(c32.m_typeid);
+		}
+
+
+
+		cpy = (fbtFile::Chunk*)(&c32);
+	}
+
+	if (cpy->m_len == FBT_NPOS)
+	{
+		FBT_INVALID_LEN;
+		return fbtFile::FS_INV_LENGTH;
+	}
+
+	fbtMemcpy(dest, cpy, BlockSize);
+	return bytesRead;
+}
Index: extern/FileTools/File/fbtFile.h
===================================================================
--- extern/FileTools/File/fbtFile.h	(revisione 0)
+++ extern/FileTools/File/fbtFile.h	(revisione 0)
@@ -0,0 +1,205 @@
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Tables).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+#ifndef _fbtFile_h_
+#define _fbtFile_h_
+
+#include "fbtTypes.h"
+
+/** \addtogroup FBT
+*  @{
+*/
+
+class fbtStream;
+class fbtBinTables;
+
+
+class fbtFile
+{
+public:
+
+	enum FileMagic
+	{
+		FM_BIG_ENDIAN       = 'V',
+		FM_LITTLE_ENDIAN    = 'v',
+		FM_32_BIT           = '_',
+		FM_64_BIT           = '-',
+
+		// place custom rules here, note that the
+		// full header string must be <= 12 char's
+	};
+
+
+	enum FileStatus
+	{
+		FS_LINK_FAILED = -7,
+		FS_INV_INSERT,
+		FS_BAD_ALLOC,
+		FS_INV_READ,
+		FS_INV_LENGTH,
+		FS_INV_HEADER_STR,
+		FS_FAILED,
+		FS_OK,
+	};
+
+
+	enum ParseMode
+	{
+		PM_UNCOMPRESSED,
+		PM_COMPRESSED,
+		PM_READTOMEMORY,
+
+	};
+
+	enum FileHeader
+	{
+		FH_ENDIAN_SWAP  = (1 << 0),
+		FH_CHUNK_64     = (1 << 1),
+		FH_VAR_BITS     = (1 << 2),
+	};
+
+
+	struct Chunk32
+	{
+		FBTuint32       m_code;
+		FBTuint32       m_len;
+		FBTuint32       m_old;
+		FBTuint32       m_typeid;
+		FBTuint32       m_nr;
+	};
+
+	struct Chunk64
+	{
+		FBTuint32       m_code;
+		FBTuint32       m_len;
+		FBTuint64       m_old;
+		FBTuint32       m_typeid;
+		FBTuint32       m_nr;
+	};
+
+
+	struct Chunk
+	{
+		FBTuint32       m_code;
+		FBTuint32       m_len;
+		FBTsize         m_old;
+		FBTuint32       m_typeid;
+		FBTuint32       m_nr;
+	};
+
+
+	struct MemoryChunk
+	{
+		enum Flag
+		{
+			BLK_MODIFIED = (1 << 0),
+		};
+
+		MemoryChunk* m_next, *m_prev;
+		Chunk        m_chunk;
+		void*        m_block;
+		void*        m_newBlock;
+
+
+		FBTuint8     m_flag;
+		FBTtype      m_newTypeId;
+	};
+
+public:
+
+
+	fbtFile(const char* uid);
+	virtual ~fbtFile();
+
+
+	int parse(const char* path, int mode = PM_UNCOMPRESSED);
+	int parse(const void* memory, FBTsize sizeInBytes, int mode = PM_UNCOMPRESSED);
+
+	/// Saving in non native endianness is not implemented yet.
+	int reflect(const char* path, const int mode = PM_UNCOMPRESSED, const fbtEndian& endian = FBT_ENDIAN_NATIVE);
+
+
+	const fbtFixedString<12>&   getHeader(void)     const {return m_header;}
+	const int&                  getVersion(void)    const {return m_fileVersion;}
+	const char*                 getPath(void)       const {return m_curFile; }
+
+
+	fbtBinTables* getMemoryTable(void)  {return m_memory;}
+	fbtBinTables* getFileTable(void)    {return m_file;}
+
+
+	fbtList& getChunks(void) {return m_chunks;}
+
+    virtual void setIgnoreList(FBTuint32 *stripList) {}
+
+	bool _setuid(const char* uid);
+
+protected:
+
+	int parseMagic(const char* cp);
+
+	void writeStruct(fbtStream* stream, FBTtype index, FBTuint32 code, FBTsize len, void* writeData);
+	void writeBuffer(fbtStream* stream, FBTsize len, void* writeData);
+
+
+	virtual int initializeTables(fbtBinTables* tables) = 0;
+	virtual int notifyData(void* p, const Chunk& id) {return FS_OK;}
+	virtual int writeData(fbtStream* stream) {return FS_OK;}
+	
+	virtual void*   getFBT(void) = 0;
+	virtual FBTsize getFBTlength(void) = 0;
+
+
+	// lookup name first 7 of 12
+	const char* m_uhid;
+	const char* m_aluhid; //alternative header string
+	fbtFixedString<12> m_header;
+
+
+	int m_version, m_fileVersion, m_fileHeader;
+	char* m_curFile;
+
+	typedef fbtHashTable<fbtSizeHashKey, MemoryChunk*> ChunkMap;
+	fbtList     m_chunks;
+	ChunkMap    m_map;
+	fbtBinTables* m_memory, *m_file;
+
+
+	virtual bool skip(const FBTuint32& id) {return false;}
+	void* findPtr(const FBTsize& iptr);
+	MemoryChunk* findBlock(const FBTsize& iptr);
+
+private:
+
+
+	int parseHeader(fbtStream* stream);
+	int parseStreamImpl(fbtStream* stream);
+
+	int compileOffsets(void);
+	int link(void);
+};
+
+/** @}*/
+#endif//_fbtFile_h_
Index: extern/FileTools/File/fbtPlatformHeaders.h
===================================================================
--- extern/FileTools/File/fbtPlatformHeaders.h	(revisione 0)
+++ extern/FileTools/File/fbtPlatformHeaders.h	(revisione 0)
@@ -0,0 +1,61 @@
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Tables).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+#ifndef _fbtPlatformHeaders_h_
+#define _fbtPlatformHeaders_h_
+
+#ifndef FBT_IN_SOURCE
+#error source include only!
+#endif
+
+#if FBT_PLATFORM == FBT_PLATFORM_WIN32
+# if FBT_COMPILER == FBT_COMPILER_MSVC
+#   define _WIN32_WINNT 0x403
+# endif
+# ifndef WIN32_LEAN_AND_MEAN
+#  define WIN32_LEAN_AND_MEAN 1
+# endif
+# include <windows.h>
+# include <io.h>
+#else
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <memory.h>
+
+#ifdef _MSC_VER
+#pragma warning(disable : 4996)
+#endif
+
+#if FBT_COMPILER == FBT_COMPILER_MSVC
+# define fbtp_printf(ptr, size, fmt, lst) _vsnprintf_s(ptr, size, fmt, lst)
+#else
+# define fbtp_printf vsnprintf
+#endif
+
+#endif//_fbtPlatformHeaders_h_
Index: extern/FileTools/File/fbtScanner.l
===================================================================
--- extern/FileTools/File/fbtScanner.l	(revisione 0)
+++ extern/FileTools/File/fbtScanner.l	(revisione 0)
@@ -0,0 +1,301 @@
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Table.).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+%{
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <memory.h>
+#ifdef _MSC_VER
+#pragma warning(disable : 4996)
+#endif
+
+// Scalar types are defined as [a-z]"Scalar"
+#ifdef FBT_SCALAR_DOUBLE
+#define scalar_t double
+#else
+#define scalar_t float
+#endif
+
+typedef enum fbtTokenID {
+
+    COMMA       = ',',
+    POINTER     = '*',
+    LBRACE      = '[',
+    RBRACE      = ']',
+    LPARN       = '(',
+    RPARN       = ')',
+    LBRACKET    = '{',
+    RBRACKET    = '}',
+    TERM        = ';',
+
+
+    IDENTIFIER = 256,
+    CHAR,
+    SHORT,
+    INT,
+    LONG,
+    FLOAT,
+    DOUBLE,
+    SCALAR,
+    VOID,
+    FUNCTION_POINTER_BEG,
+    FUNCTION_POINTER_END,
+    CONSTANT,
+
+    NAMESPACE,
+    CLASS,
+    STRUCT,
+    UNION, 
+
+    NULL_TOKEN,
+}fbtTokenID;
+
+#define FBT_TOK_IS_TYPE(x) (x >= IDENTIFIER && x <= VOID)
+#define ECHO 
+
+int line = 1;
+fbtFixedString<270> __source;
+
+
+
+%}
+%option noyywrap
+%option never-interactive
+%s OSTRC ISTRC IGENUM ISENUM ICMT GCMT PSCMT PRIVSEC INSP SSTRC
+
+D           [0-9]
+L           [a-zA-Z_]
+H           [a-fA-F0-9]
+E           [Ee][+-]?{D}+
+FS          (f|F|l|L)
+IS          (u|U|l|L)*
+l           [a-z]
+WS          [ \t]+
+ID          {L}({L}|{D})*
+FWDCLS      "class"{WS}*{ID}*{WS}*";"
+FWDSTC      "struct"{WS}*{ID}*{WS}*";"
+TYPETERM    "}"{WS}*{ID}*{WS}*";"
+
+
+PRE         "#"{L}[^\n\r]+
+
+
+
+%{
+FBTsize         m_lastConstant;
+
+
+struct fbtToken
+{
+    fbtTokenID  m_cur;
+    char*       m_buf;
+    FBTsize     m_constantSize;
+    FBTsize     m_line;
+    char*       m_src;
+};
+
+
+
+%}
+
+
+%%
+
+<OSTRC>"\n"                 { line ++; }
+<OSTRC>"\r\n"               { line ++; }
+<OSTRC>"\r"                 { line ++; }
+<OSTRC>{FWDCLS}*            { }
+<OSTRC>{FWDSTC}*            { }
+<OSTRC>"namespace"          { BEGIN INSP;  return (NAMESPACE); }
+<OSTRC>"struct"             { BEGIN ISTRC; return STRUCT; }
+<OSTRC>"class"              { BEGIN ISTRC; return STRUCT; }
+<OSTRC>"enum"               { BEGIN IGENUM; }
+<OSTRC>{PRE}*               { }
+<OSTRC>"#"                  { BEGIN SSTRC; }
+<OSTRC>"/*"                 { BEGIN GCMT; }
+<OSTRC>"//"[^\n\r]+         { }
+<OSTRC>[.]+                 { }
+
+<INSP>{L}({L}|{D})*         { return IDENTIFIER; }
+<INSP>"{"                   { BEGIN OSTRC; }
+
+<ISTRC>"/*"                 { BEGIN ICMT; }
+<ISTRC>"//"[^\n\r]+         { }
+<ISTRC>"privsec:"           { BEGIN PRIVSEC;}
+<ISTRC>"public:"            { }
+<ISTRC>"private:"           { }
+<ISTRC>"protected:"         { }
+<ISTRC>"enum"               { BEGIN ISENUM; }
+<ISTRC>"("[ \t\*]+          { return FUNCTION_POINTER_BEG; }
+<ISTRC>")"[^;]+             { return FUNCTION_POINTER_END; }
+<ISTRC>"char" |
+<ISTRC>"uchar"              { return CHAR; }
+<ISTRC>"short" |           
+<ISTRC>"ushort"             { return SHORT; }
+<ISTRC>"int" |
+<ISTRC>"uint"               { return INT; }
+<ISTRC>"long" |        
+<ISTRC>"ulong"              { return LONG;      }
+<ISTRC>"float"              { return FLOAT;     }
+<ISTRC>"double"             { return DOUBLE;    }
+<ISTRC>[a-z]+"Scalar"       { return SCALAR;    }
+<ISTRC>"void"               { return VOID;      }
+<ISTRC>"struct"             { }
+<ISTRC>"class"              { }
+<ISTRC>"signed"             { }
+<ISTRC>"unsigned"           { }
+<ISTRC>"static"             { }
+<ISTRC>"typedef"            { }
+<ISTRC>"*"                  { return POINTER;       }
+<ISTRC>"["                  { return LBRACE;        }
+<ISTRC>"]"                  { return RBRACE;        }
+<ISTRC>"{"                  { return LBRACKET;      }
+<ISTRC>"("                  { return LPARN;         }
+<ISTRC>")"                  { return RPARN;         }
+<ISTRC>","                  { return COMMA;         }
+<ISTRC>";"                  { return TERM;          }
+<ISTRC>{L}({L}|{D})*        { return IDENTIFIER;    }
+<ISTRC>{TYPETERM}*          { BEGIN OSTRC; return RBRACKET; }
+<ISTRC>{D}+{IS}?            { m_lastConstant = atoi(yytext); return(CONSTANT); }
+<ISTRC>"\n"                 { line ++; }
+<ISTRC>"\r\n"               { line ++; }
+<ISTRC>"\r"                 { line ++; }
+<ISTRC>[ \t\v\f]            { }
+
+
+<ICMT>"\n"                  { line ++; }
+<ICMT>"\r\n"                { line ++; }
+<ICMT>"\r"                  { line ++; }
+<ICMT>"*/"                  { BEGIN ISTRC; }
+<ICMT>[.]+                  { }
+
+<GCMT>"\n"                  { line ++; }
+<GCMT>"\r\n"                { line ++; }
+<GCMT>"\r"                  { line ++; }
+<GCMT>"*/"                  { BEGIN OSTRC; }
+<GCMT>[.]+                  { }
+
+<PSCMT>"\n"                 { line ++; }
+<PSCMT>"\r\n"               { line ++; }
+<PSCMT>"\r"                 { line ++; }
+<PSCMT>"*/"                 { BEGIN PRIVSEC; }
+<PSCMT>[.]+                 { }
+
+
+<PRIVSEC>"/*"               { BEGIN PSCMT; }
+<PRIVSEC>"//"[^\n\r]+       { }
+<PRIVSEC>"\n"               { line ++; }
+<PRIVSEC>"\r\n"             { line ++; }
+<PRIVSEC>"\r"               { line ++; }
+<PRIVSEC>"public:"          { BEGIN ISTRC; }
+<PRIVSEC>"private:"         { BEGIN ISTRC; }
+<PRIVSEC>"protected:"       { BEGIN ISTRC; }
+<PRIVSEC>[.]+               { }
+
+
+<SSTRC>"\n"                 { line ++;      }
+<SSTRC>"\r\n"               { line ++;      }
+<SSTRC>"\r"                 { line ++;      }
+<SSTRC>"}"                  { BEGIN OSTRC;  }
+<SSTRC>[.]+                 { }
+
+
+<IGENUM>"\n"                { line ++;      }
+<IGENUM>"\r\n"              { line ++;      }
+<IGENUM>"\r"                { line ++;      }
+<IGENUM>{TYPETERM}*         { BEGIN OSTRC;  }
+<IGENUM>[.]+                { }
+
+<ISENUM>"\n"                { line ++;      }
+<ISENUM>"\r\n"              { line ++;      }
+<ISENUM>"\r"                { line ++;      }
+<ISENUM>{TYPETERM}*         { BEGIN ISTRC;  }
+<ISENUM>[.]+                { }
+
+
+%%
+
+fbtTokenID fbtLex()
+{
+    return (fbtTokenID)fbtlex();
+}
+
+fbtTokenID fbtLex(fbtToken &tok)
+{
+    tok.m_cur           = fbtLex();
+    tok.m_buf           = yytext;
+    tok.m_constantSize  = m_lastConstant;
+    tok.m_line          = line;
+    tok.m_src           = (char*)__source.c_str();
+    m_lastConstant      = -1;
+    return tok.m_cur;
+}
+
+void *fbtCurFile = 0;
+yy_buffer_state *fbtCurBuf = 0;
+
+void* fbtInitParse(const char *ifile)
+{
+    line    = 1;
+    BEGIN   OSTRC;
+    __source = ifile;
+
+
+    fbtCurFile = (void*)fopen(ifile, "rb");
+    if (!fbtCurFile)
+    {
+        fbtPrintf("File '%s' loading failed!\n", ifile);
+        return 0;
+    }
+
+    yyin = (FILE*)fbtCurFile;
+    return fbtCurFile;
+}
+
+
+void* fbtInitParse(const char *name, const char *buf)
+{
+    line    = 1;
+    BEGIN   OSTRC;
+    __source = name;
+
+    fbtCurBuf = fbt_scan_string(buf);
+    return fbtCurBuf;
+}
+
+void fbtFreeParse(void *p)
+{   
+    if (p == fbtCurBuf)
+    {
+        fbt_delete_buffer(fbtCurBuf);
+        return;
+    }
+
+
+    if (p == fbtCurFile)
+        fclose((FILE*)fbtCurFile);
+}
Index: extern/FileTools/File/fbtStreams.cpp
===================================================================
--- extern/FileTools/File/fbtStreams.cpp	(revisione 0)
+++ extern/FileTools/File/fbtStreams.cpp	(revisione 0)
@@ -0,0 +1,432 @@
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Tables).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+#define FBT_IN_SOURCE
+#include "fbtStreams.h"
+#include "fbtPlatformHeaders.h"
+
+
+#if FBT_USE_GZ_FILE == 1
+#include "zlib.h"
+#endif
+
+
+fbtFileStream::fbtFileStream() 
+	:    m_file(), m_handle(0), m_mode(0), m_size(0)
+{
+}
+
+
+fbtFileStream::~fbtFileStream()
+{
+	close();
+}
+
+
+
+void fbtFileStream::open(const char* p, fbtStream::StreamMode mode)
+{
+	if (m_handle != 0 && m_file != p)
+		fclose((FILE *)m_handle);
+
+	char fm[3] = {0, 0, 0};
+	char* mp = &fm[0];
+	if (mode & fbtStream::SM_READ)
+		*mp++ = 'r';
+	else if (mode & fbtStream::SM_WRITE)
+		*mp++ = 'w';
+	*mp++ = 'b';
+	fm[2] = 0;
+
+	m_file = p;
+	m_handle = fopen(m_file.c_str(), fm);
+
+	if (m_handle && (mode & fbtStream::SM_READ))
+	{
+		FILE *fp = (FILE*)m_handle;
+
+		position();
+		fseek(fp, 0, SEEK_END);
+		m_size = ftell(fp);
+		fseek(fp, 0, SEEK_SET);
+	}
+
+
+}
+
+
+void fbtFileStream::close(void)
+{
+	if (m_handle != 0)
+	{
+		fclose((FILE*)m_handle);
+		m_handle = 0;
+	}
+
+	m_file.clear();
+}
+
+
+bool fbtFileStream::eof(void) const
+{
+	if (!m_handle)
+		return true;
+	return feof((FILE*)m_handle) != 0;
+}
+
+FBTsize fbtFileStream::position(void) const
+{
+	return ftell((FILE*)m_handle);
+}
+
+
+FBTsize fbtFileStream::size(void) const
+{
+	return m_size;
+}
+
+FBTsize fbtFileStream::seek(FBTint32 off, FBTint32 way)
+{
+	if (!m_handle)
+		return 0;
+
+	return fseek((FILE*)m_handle, off, way);
+}
+
+
+FBTsize fbtFileStream::read(void* dest, FBTsize nr) const
+{
+	if (m_mode == fbtStream::SM_WRITE) 
+		return -1;
+
+	if (!dest || !m_handle) 
+		return -1;
+
+	return fread(dest, 1, nr, (FILE *)m_handle);
+}
+
+
+
+FBTsize fbtFileStream::write(const void* src, FBTsize nr)
+{
+	if (m_mode == fbtStream::SM_READ) return -1;
+	if (!src || !m_handle) return -1;
+
+	return fwrite(src, 1, nr, (FILE*)m_handle);
+}
+
+void fbtFileStream::write(fbtMemoryStream &ms) const
+{
+	FILE *fp = (FILE*)m_handle;
+
+	int oldPos = ftell(fp);
+
+	fseek(fp, 0, SEEK_END);
+	int len = ftell(fp);
+	fseek(fp, 0, SEEK_SET);
+
+	ms.reserve(len + 1);
+	ms.m_size = read(ms.m_buffer, len);
+
+	fseek(fp, oldPos, SEEK_SET);
+}
+
+
+FBTsize fbtFileStream::writef(const char* fmt, ...)
+{
+	static char tmp[1024];
+
+	va_list lst;
+	va_start(lst, fmt);
+	int size = fbtp_printf(tmp, 1024, fmt, lst);
+	va_end(lst);
+
+	if (size > 0)
+	{
+		tmp[size] = 0;
+		return write(tmp, size);
+	}
+	return -1;
+
+}
+
+
+#if FBT_USE_GZ_FILE == 1
+
+
+fbtGzStream::fbtGzStream() 
+	:    m_file(), m_handle(0), m_mode(0)
+{
+}
+
+
+fbtGzStream::~fbtGzStream()
+{
+	close();
+}
+
+
+void fbtGzStream::open(const char* p, fbtStream::StreamMode mode)
+{
+	if (m_handle != 0 && m_file != p)
+		gzclose(m_handle);
+
+	char fm[3] = {0, 0, 0};
+	char* mp = &fm[0];
+	if (mode & fbtStream::SM_READ)
+		*mp++ = 'r';
+	else if (mode & fbtStream::SM_WRITE)
+		*mp++ = 'w';
+	*mp++ = 'b';
+	fm[2] = 0;
+
+	m_file = p;
+	m_handle = gzopen(m_file.c_str(), fm);
+}
+
+
+void fbtGzStream::close(void)
+{
+	if (m_handle != 0)
+	{
+		gzclose(m_handle);
+		m_handle = 0;
+	}
+
+	m_file.clear();
+}
+
+
+
+FBTsize fbtGzStream::read(void* dest, FBTsize nr) const
+{
+	if (m_mode == fbtStream::SM_WRITE) return -1;
+	if (!dest || !m_handle) 
+		return -1;
+
+	return gzread(m_handle, dest, nr);
+}
+
+
+FBTsize fbtGzStream::write(const void* src, FBTsize nr)
+{
+	if (m_mode == fbtStream::SM_READ) return -1;
+	if (!src || !m_handle) return -1;
+	return gzwrite(m_handle, src, nr);
+}
+
+
+bool fbtGzStream::eof(void) const
+{
+	if (!m_handle)
+		return true;
+	return gzeof(m_handle) != 0;
+}
+
+FBTsize fbtGzStream::position(void) const
+{
+	return gztell(m_handle);
+}
+
+FBTsize fbtGzStream::size(void) const
+{
+	return 0;
+}
+
+
+FBTsize fbtGzStream::writef(const char* fmt, ...)
+{
+	static char tmp[1024];
+
+	va_list lst;
+	va_start(lst, fmt);
+	int size = fbtp_printf(tmp, 1024, fmt, lst);
+	va_end(lst);
+
+	if (size > 0)
+	{
+		tmp[size] = 0;
+		return write(tmp, size);
+	}
+	return -1;
+
+}
+
+#endif
+
+
+
+
+fbtMemoryStream::fbtMemoryStream()
+	:   m_buffer(0), m_pos(0), m_size(0), m_capacity(0), m_mode(0)
+{
+}
+
+
+void fbtMemoryStream::open(fbtStream::StreamMode mode)
+{
+	m_mode = mode;
+}
+
+void fbtMemoryStream::open(const char* path, fbtStream::StreamMode mode)
+{
+	fbtFileStream fs;
+	fs.open(path, fbtStream::SM_READ);
+
+	if (fs.isOpen()) 
+		open(fs, mode);
+}
+
+
+void fbtMemoryStream::open(const fbtFileStream& fs, fbtStream::StreamMode mode)
+{
+	if (fs.isOpen())
+	{
+		fs.write(*this);
+		m_mode = mode;
+	}
+}
+
+
+void fbtMemoryStream::open(const void* buffer, FBTsize size, fbtStream::StreamMode mode)
+{
+	if (buffer && size > 0 && size != FBT_NPOS)
+	{
+		m_mode = mode;
+		m_size = size;
+		m_pos  = 0;
+		fbtMemcpy(m_buffer, buffer, m_size);
+	}
+}
+
+
+fbtMemoryStream::~fbtMemoryStream()
+{
+	if (m_buffer != 0)
+	{
+		delete []m_buffer;
+		m_buffer = 0;
+	}
+	m_size = m_pos = 0;
+	m_capacity = 0;
+}
+
+
+
+void fbtMemoryStream::clear(void)
+{
+	m_size = m_pos = 0;
+	if (m_buffer)
+		m_buffer[0] = 0;
+}
+
+
+FBTsize fbtMemoryStream::seek(FBTint32 off, FBTint32 way)
+{
+	if (way == SEEK_SET)
+		m_pos = fbtClamp<FBTsize>(off, 0, m_size);
+	else if (way == SEEK_CUR)
+		m_pos = fbtClamp<FBTsize>(m_pos + off, 0, m_size);
+	else if (way == SEEK_END)
+		m_pos = m_size;
+	return m_pos;
+}
+
+
+
+FBTsize fbtMemoryStream::read(void* dest, FBTsize nr) const
+{
+	if (m_mode == fbtStream::SM_WRITE) return -1;
+	if (m_pos > m_size) return 0;
+	if (!dest || !m_buffer) return 0;
+
+	if ((m_size - m_pos) < nr) nr = m_size - m_pos;
+
+	char* cp = (char*)dest;
+	char* op = (char*)&m_buffer[m_pos];
+	fbtMemcpy(cp, op, nr);
+	m_pos += nr;
+	return nr;
+}
+
+
+
+FBTsize fbtMemoryStream::write(const void* src, FBTsize nr)
+{
+	if (m_mode == fbtStream::SM_READ || !src)
+		return -1;
+
+	if (m_pos > m_size) return 0;
+
+	if (m_buffer == 0)
+		reserve(m_pos + (nr));
+	else if (m_pos + nr > m_capacity)
+		reserve(m_pos + (nr > 65535 ? nr : nr + 65535));
+
+	char* cp = &m_buffer[m_pos];
+	fbtMemcpy(cp, (char*)src, nr);
+
+	m_pos   += nr;
+	m_size  += nr;
+	return nr;
+}
+
+
+
+FBTsize fbtMemoryStream::writef(const char* fmt, ...)
+{
+	static char tmp[1024];
+
+	va_list lst;
+	va_start(lst, fmt);
+	int size = fbtp_printf(tmp, 1024, fmt, lst);
+	va_end(lst);
+
+
+	if (size > 0)
+	{
+		tmp[size] = 0;
+		return write(tmp, size);
+	}
+
+	return -1;
+
+}
+void fbtMemoryStream::reserve(FBTsize nr)
+{
+	if (m_capacity < nr)
+	{
+		char* buf = new char[nr + 1];
+		if (m_buffer != 0)
+		{
+			fbtMemcpy(buf, m_buffer, m_size);
+			delete [] m_buffer;
+		}
+
+		m_buffer = buf;
+		m_buffer[m_size] = 0;
+		m_capacity = nr;
+	}
+}
Index: extern/FileTools/File/fbtStreams.h
===================================================================
--- extern/FileTools/File/fbtStreams.h	(revisione 0)
+++ extern/FileTools/File/fbtStreams.h	(revisione 0)
@@ -0,0 +1,187 @@
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Tables).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+#ifndef _fbtStreams_h_
+#define _fbtStreams_h_
+
+
+#include "fbtTypes.h"
+
+/** \addtogroup FBT
+*  @{
+*/
+
+class fbtStream
+{
+public:
+	enum StreamMode
+	{
+		SM_READ = 1,
+		SM_WRITE = 2,
+	};
+
+public:
+	fbtStream() {}
+	virtual ~fbtStream() {}
+
+	virtual void open(const char* path, fbtStream::StreamMode mode) {}
+	virtual void clear(void) {};
+
+
+	virtual bool isOpen(void) const = 0;
+	virtual bool eof(void) const = 0;
+
+	virtual FBTsize  read(void* dest, FBTsize nr) const = 0;
+	virtual FBTsize  write(const void* src, FBTsize nr) = 0;
+	virtual FBTsize  writef(const char* fmt, ...) {return 0;};
+
+	virtual FBTsize  position(void) const = 0;
+	virtual FBTsize  size(void) const = 0;
+
+	virtual FBTsize seek(FBTint32 off, FBTint32 way) {return 0;}
+
+protected:
+	virtual void reserve(FBTsize nr) {}
+};
+
+
+
+class           fbtMemoryStream;
+typedef void*   fbtFileHandle;
+
+
+class fbtFileStream : public fbtStream
+{
+public:
+	fbtFileStream();
+	~fbtFileStream();
+
+	void open(const char* path, fbtStream::StreamMode mode);
+	void close(void);
+
+	bool isOpen(void)   const {return m_handle != 0;}
+	bool eof(void)      const;
+
+	FBTsize  read(void* dest, FBTsize nr) const;
+	FBTsize  write(const void* src, FBTsize nr);
+	FBTsize  writef(const char* buf, ...);
+
+
+	FBTsize  position(void) const;
+	FBTsize  size(void)     const;
+	FBTsize seek(FBTint32 off, FBTint32 way);
+
+	void write(fbtMemoryStream &ms) const;
+
+protected:
+
+
+	fbtFixedString<272> m_file;
+	fbtFileHandle       m_handle;
+	int                 m_mode;
+	int					m_size;
+};
+
+
+
+
+#if FBT_USE_GZ_FILE == 1
+
+class fbtGzStream : public fbtStream
+{
+public:
+	fbtGzStream();
+	~fbtGzStream();
+
+	void open(const char* path, fbtStream::StreamMode mode);
+	void close(void);
+
+	bool isOpen(void)   const {return m_handle != 0;}
+	bool eof(void)      const;
+
+	FBTsize  read(void* dest, FBTsize nr) const;
+	FBTsize  write(const void* src, FBTsize nr);
+	FBTsize  writef(const char* buf, ...);
+
+
+	FBTsize  position(void) const;
+	FBTsize size(void) const;
+
+	// watch it no size / seek
+
+protected:
+
+
+	fbtFixedString<272> m_file;
+	fbtFileHandle       m_handle;
+	int                 m_mode;
+};
+
+
+#endif
+
+
+class fbtMemoryStream : public fbtStream
+{
+public:
+	fbtMemoryStream();
+	~fbtMemoryStream();
+
+	void clear(void);
+
+	void open(fbtStream::StreamMode mode);
+	void open(const char* path, fbtStream::StreamMode mode);
+	void open(const fbtFileStream& fs, fbtStream::StreamMode mode);
+	void open(const void* buffer, FBTsize size, fbtStream::StreamMode mode);
+
+
+	bool     isOpen(void)    const   {return m_buffer != 0;}
+	bool     eof(void)       const   {return !m_buffer || m_pos >= m_size;}
+	FBTsize  position(void)  const   {return m_pos;}
+	FBTsize  size(void)      const   {return m_size;}
+
+	FBTsize  read(void* dest, FBTsize nr) const;
+	FBTsize  write(const void* src, FBTsize nr);
+	FBTsize  writef(const char* buf, ...);
+
+
+	void*            ptr(void)          {return m_buffer;}
+	const void*      ptr(void) const    {return m_buffer;}
+
+	FBTsize seek(FBTint32 off, FBTint32 way);
+
+
+	void reserve(FBTsize nr);
+protected:
+	friend class fbtFileStream;
+
+	char*            m_buffer;
+	mutable FBTsize  m_pos;
+	FBTsize          m_size, m_capacity;
+	int              m_mode;
+};
+
+/** @}*/
+#endif//_fbtStreams_h_
Index: extern/FileTools/File/fbtTables.cpp
===================================================================
--- extern/FileTools/File/fbtTables.cpp	(revisione 0)
+++ extern/FileTools/File/fbtTables.cpp	(revisione 0)
@@ -0,0 +1,506 @@
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Tables).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+#define FBT_IN_SOURCE
+#include "fbtTables.h"
+#include "fbtPlatformHeaders.h"
+
+
+FBTsizeType fbtStruct::getUnlinkedMemberCount()
+{
+	FBTsizeType count = 0;
+	for (FBTsizeType i = 0; i < m_members.size(); i++)
+		if (!m_members[i].m_link) count++;
+
+	return count;
+}
+
+
+fbtBinTables::fbtBinTables()
+	:   m_name(0),
+	    m_type(0),
+	    m_tlen(0),
+	    m_strc(0),
+	    m_nameNr(0),
+	    m_typeNr(0),
+	    m_strcNr(0),
+	    m_ptr(FBT_VOID),
+	    m_otherBlock(0),
+	    m_otherLen(0)
+{
+}
+
+fbtBinTables::fbtBinTables(void* ptr, const FBTsize& len)
+	:   m_name(0),
+	    m_type(0),
+	    m_tlen(0),
+	    m_strc(0),
+	    m_nameNr(0),
+	    m_typeNr(0),
+	    m_strcNr(0),
+	    m_ptr(FBT_VOID),
+	    m_otherBlock(ptr),
+	    m_otherLen(len)
+{
+}
+
+fbtBinTables::~fbtBinTables()
+{
+	fbtFree(m_name);
+	fbtFree(m_type);
+	fbtFree(m_tlen);
+	fbtFree(m_strc);
+	if (m_otherBlock)
+		fbtFree(m_otherBlock);
+
+
+	OffsM::Iterator it = m_offs.iterator();
+	while (it.hasMoreElements())
+		delete it.getNext();
+}
+
+
+bool fbtBinTables::read(bool swap)
+{
+	if (m_otherBlock && m_otherLen != 0)
+		return read(m_otherBlock, m_otherLen, swap);
+	return false;
+}
+
+
+bool fbtBinTables::read(const void* ptr, const FBTsize& len, bool swap)
+{
+	FBTuint32* ip = 0, i, j, k, nl;
+	FBTtype* tp = 0;
+
+	char* cp = (char*)ptr;
+
+
+	if (!fbtCharNEq(cp, fbtIdNames::FBT_SDNA, FBT_MAGIC))
+	{
+		fbtPrintf("Bin table is missing the start id!\n");
+		return false;
+	}
+
+	cp += FBT_MAGIC;
+
+
+	if (!fbtCharNEq(cp, fbtIdNames::FBT_NAME, FBT_MAGIC))
+	{
+		fbtPrintf("Bin table is missing the name id!\n");
+		return false;
+	}
+
+	cp += FBT_MAGIC;
+
+
+	FBTintPtr opad;
+
+	ip = (FBTuint32*)cp;
+	nl = *ip++;
+	cp = (char*)ip;
+
+	if (swap) nl = fbtSwap32(nl);
+
+
+	if (nl > fbtMaxTable)
+	{
+		fbtPrintf("Max name table size exceeded!\n");
+		return false;
+	}
+	else
+	{
+		m_name = (Names)fbtMalloc((nl * sizeof(fbtName)) + 1);
+	}
+
+
+
+	i = 0;
+	while (i < nl && i < fbtMaxTable)
+	{
+		fbtName name = {cp, i, fbtCharHashKey(cp).hash(), 0, 0, 0, 1};
+
+		fbtFixedString<64> bn;
+
+		// re-lex
+		while (*cp)
+		{
+			switch (*cp)
+			{
+			default:
+				{
+					bn.push_back(*cp);
+					++cp; break;
+				}
+			case ')':
+			case ']':
+				++cp;
+				break;
+			case '(':   {++cp; name.m_isFptr = 1; break;    }
+			case '*':   {++cp; name.m_ptrCount ++; break;   }
+			case '[':
+				{
+					while ((*++cp) != ']')
+						name.m_slots[name.m_numSlots] = (name.m_slots[name.m_numSlots] * 10) + ((*cp) - '0');
+					name.m_arraySize *= name.m_slots[name.m_numSlots++];
+				}
+				break;
+			}
+		}
+		++cp;
+
+		//fbtPrintf("%d %d: %s %s %u %u\n", m_nameNr, m_base.size(), name.m_name, bn.c_str(), name.m_nameId, bn.hash());
+
+		m_name[m_nameNr++] = name;
+		m_base.push_back(bn.hash());
+		++i;
+	}
+
+	// read alignment
+	opad = (FBTintPtr)cp;
+	opad = ((opad + 3) & ~3) - opad;
+	while (opad--) cp++;
+
+	if (!fbtCharNEq(cp, fbtIdNames::FBT_TYPE, FBT_MAGIC))
+	{
+		fbtPrintf("Bin table is missing the type id!\n");
+		return false;
+	}
+
+	cp += FBT_MAGIC;
+
+	ip = (FBTuint32*)cp;
+	nl = *ip++;
+	cp = (char*)ip;
+
+	if (swap) nl = fbtSwap32(nl);
+
+	if (nl > fbtMaxTable)
+	{
+		fbtPrintf("Max name table size exceeded!\n");
+		return false;
+	}
+	else
+	{
+		m_type = (Types)fbtMalloc((nl * sizeof(fbtType) + 1));
+		m_tlen = (TypeL)fbtMalloc((nl * sizeof(FBTtype) + 1));
+	}
+
+	i = 0;
+	while (i < nl)
+	{
+		fbtType typeData = {cp, fbtCharHashKey(cp).hash(), -1};
+		m_type[m_typeNr++] = typeData;
+		while (*cp) ++cp;
+		++cp;
+		++i;
+	}
+
+	// read alignment
+	opad = (FBTintPtr)cp;
+	opad = ((opad + 3) & ~3) - opad;
+	while (opad--) cp++;
+
+	if (!fbtCharNEq(cp, fbtIdNames::FBT_TLEN, FBT_MAGIC))
+	{
+		fbtPrintf("Bin table is missing the tlen id!\n");
+		return false;
+	}
+
+	cp += FBT_MAGIC;
+
+	tp = (FBTtype*)cp;
+
+	i = 0;
+	while (i < m_typeNr)
+	{
+
+		m_tlen[i] = *tp++;
+		if (swap)
+			m_tlen[i] = fbtSwap16(m_tlen[i]);
+		++i;
+	}
+
+	// read alignment
+	if (m_typeNr & 1) ++tp;
+
+	cp = (char*)tp;
+
+	if (!fbtCharNEq(cp, fbtIdNames::FBT_STRC, FBT_MAGIC))
+	{
+		fbtPrintf("Bin table is missing the tlen id!\n");
+		return false;
+	}
+
+	cp += FBT_MAGIC;
+
+
+	ip = (FBTuint32*)cp;
+	nl = *ip++;
+	tp = (FBTtype*)ip;
+
+	if (swap) nl = fbtSwap32(nl);
+
+	if (nl > fbtMaxTable)
+	{
+		fbtPrintf("Max name table size exceeded!\n");
+		return false;
+	}
+	else
+		m_strc = (Strcs)fbtMalloc(nl * fbtMaxMember * sizeof(FBTtype) + 1);
+
+
+	m_typeFinder.reserve(m_typeNr);
+
+
+	i = 0;
+	while (i < nl)
+	{
+		m_strc[m_strcNr++] = tp;
+
+
+		if (swap)
+		{
+			tp[0] = fbtSwap16(tp[0]);
+			tp[1] = fbtSwap16(tp[1]);
+
+			m_type[tp[0]].m_strcId = m_strcNr - 1;
+
+			m_typeFinder.insert(m_type[tp[0]].m_name, m_type[tp[0]]);
+
+
+			k = tp[1];
+			FBT_ASSERT( k < fbtMaxMember );
+
+			j = 0;
+			tp += 2;
+
+			while (j < k)
+			{
+				tp[0] = fbtSwap16(tp[0]);
+				tp[1] = fbtSwap16(tp[1]);
+
+				++j;
+				tp += 2;
+			}
+		}
+		else
+		{
+			FBT_ASSERT( tp[1] < fbtMaxMember );
+			m_type[tp[0]].m_strcId = m_strcNr - 1;
+			m_typeFinder.insert(m_type[tp[0]].m_name, m_type[tp[0]]);
+
+			tp += (2 * tp[1]) + 2;
+		}
+
+		++i;
+	}
+
+	if (m_strcNr == 0)
+	{
+		fbtFree(m_name);
+		fbtFree(m_type);
+		fbtFree(m_tlen);
+		fbtFree(m_strc);
+
+		m_name = 0;
+		m_type = 0;
+		m_tlen = 0;
+		m_strc = 0;
+
+		return false;
+	}
+
+	compile();
+	return true;
+}
+
+
+void fbtBinTables::compile(FBTtype i, FBTtype nr, fbtStruct* off, FBTuint32& cof, FBTuint32 depth, fbtStruct::Keys& keys)
+{
+	FBTuint32 e, l, a, oof, ol;
+	FBTuint16 f = m_strc[0][0];
+
+	if (i > m_strcNr)
+	{
+		fbtPrintf("Missing recursive type\n");
+		return;
+	}
+
+
+	for (a = 0; a < nr; ++a)
+	{
+		// Only calculate offsets on recursive structs
+		// This saves undeded buffers
+		FBTtype* strc = m_strc[i];
+
+		oof = cof;
+		ol = m_tlen[strc[0]];
+
+		l = strc[1];
+		strc += 2;
+
+		for (e = 0; e < l; e++, strc += 2)
+		{
+			if (strc[0] >= f && m_name[strc[1]].m_ptrCount == 0)
+			{
+				fbtKey64 k = {m_type[strc[0]].m_typeId, m_name[strc[1]].m_nameId};
+				keys.push_back(k);
+
+				compile(m_type[strc[0]].m_strcId, m_name[strc[1]].m_arraySize, off, cof, depth+1, keys);
+
+				keys.pop_back();
+			}
+			else
+				putMember(strc, off, a, cof, depth, keys);
+		}
+
+		if ((cof - oof) != ol)
+			fbtPrintf("Build ==> invalid offset (%i)(%i:%i)\n", a, (cof - oof), ol);
+	
+	}
+}
+
+
+
+
+void fbtBinTables::compile(void)
+{
+	m_offs.reserve(fbtMaxTable);
+
+	if (!m_strc || m_strcNr <= 0)
+	{
+		fbtPrintf("Build ==> No structurs.");
+		return;
+	}
+
+	FBTuint32 i, cof = 0, depth;
+	FBTuint16 f = m_strc[0][0], e, memberCount;
+
+	fbtStruct::Keys emptyKeys;
+	for (i = 0; i < m_strcNr; i++)
+	{
+		FBTtype* strc = m_strc[i];
+
+		FBTtype strcType = strc[0];
+
+		depth = 0;
+		cof = 0;
+		fbtStruct* off = new fbtStruct;
+		off->m_key.k16[0] = strcType;
+		off->m_key.k16[1] = 0;
+		off->m_val.k32[0] = m_type[strcType].m_typeId;
+		off->m_val.k32[1] = 0; // no name
+		off->m_nr         = 0;
+		off->m_dp         = 0;
+		off->m_off        = cof;
+		off->m_len        = m_tlen[strcType];
+		off->m_strcId     = i;
+		off->m_link       = 0;
+		off->m_flag       = fbtStruct::CAN_LINK;
+
+		m_offs.push_back(off);
+
+		memberCount = strc[1];
+
+		strc += 2;
+		off->m_members.reserve(fbtMaxMember);
+
+		for (e = 0; e < memberCount; ++e, strc += 2)
+		{
+			if (strc[0] >= f && m_name[strc[1]].m_ptrCount == 0) //strc[0]:member_type, strc[1]:member_name
+			{
+				fbtStruct::Keys keys;
+				fbtKey64 k = {m_type[strc[0]].m_typeId, m_name[strc[1]].m_nameId};
+				keys.push_back(k);
+				compile(m_type[strc[0]].m_strcId, m_name[strc[1]].m_arraySize, off, cof, depth+1, keys);				
+			}
+			else
+				putMember(strc, off, 0, cof, 0, emptyKeys);
+		}
+
+		if (cof != off->m_len)
+		{
+			off->m_flag |= fbtStruct::MISALIGNED;
+			fbtPrintf("Build ==> invalid offset %s:%i:%i:%i\n", m_type[off->m_key.k16[0]].m_name, i, cof, off->m_len);
+		}
+
+	}
+}
+
+void fbtBinTables::putMember(FBTtype* cp, fbtStruct* off, FBTtype nr, FBTuint32& cof, FBTuint32 depth, fbtStruct::Keys& keys)
+{
+	fbtStruct nof;
+	nof.m_key.k16[0] = cp[0];
+	nof.m_key.k16[1] = cp[1];
+	nof.m_val.k32[0] = m_type[cp[0]].m_typeId;
+	nof.m_val.k32[1] = m_base[cp[1]];
+	nof.m_off        = cof;
+	nof.m_strcId     = off->m_strcId;
+	nof.m_nr         = nr;
+	nof.m_dp         = depth;
+	nof.m_link       = 0;
+	nof.m_flag       = fbtStruct::CAN_LINK;
+	nof.m_len        = (m_name[cp[1]].m_ptrCount ? m_ptr : m_tlen[cp[0]]) * m_name[cp[1]].m_arraySize;
+	nof.m_keyChain   = keys;
+	off->m_members.push_back(nof);
+	cof += nof.m_len;
+
+#ifdef _DEBUG
+	//fbtPrintf("%s %s\n", getStructType(off), getStructName(off));
+	//fbtPrintf("\t%s %s nr:%d cof:%d depth:%d\n", getStructType(&nof), getStructName(&nof), nr, cof, depth);
+#endif
+}
+
+
+FBTtype fbtBinTables::findTypeId(const fbtCharHashKey &cp)
+{
+	FBTsizeType pos = m_typeFinder.find(cp);
+	if (pos != FBT_NPOS)
+		return m_typeFinder.at(pos).m_strcId;
+	return -1;
+}
+
+const char* fbtBinTables::getStructType(const fbtStruct* strc)
+{
+	
+	//return strc ? m_type[strc->m_key.k16[0]].m_name : "";
+
+	FBTuint32 k = strc ? strc->m_key.k16[0] : (FBTuint32)-1;	
+	return  (k >= m_typeNr) ? "" : m_type[k].m_name;
+}
+
+const char* fbtBinTables::getStructName(const fbtStruct* strc)
+{	
+	FBTuint32 k = strc ? strc->m_key.k16[1] : (FBTuint32)-1;	
+	return  (k >= m_nameNr) ? "" : m_name[k].m_name;
+}
+
+const char* fbtBinTables::getOwnerStructName(const fbtStruct* strc)
+{
+	//cp0 = mp->m_type[mp->m_strc[c->m_strcId][0]].m_name;
+	FBTuint32 k = strc ? strc->m_strcId : (FBTuint32)-1;
+	return (k >= m_strcNr || *m_strc[k] >= m_typeNr) ? "" : m_type[*m_strc[k]].m_name;
+}
\ No newline at end of file
Index: extern/FileTools/File/fbtTables.h
===================================================================
--- extern/FileTools/File/fbtTables.h	(revisione 0)
+++ extern/FileTools/File/fbtTables.h	(revisione 0)
@@ -0,0 +1,213 @@
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Tables).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+#ifndef _fbtTables_h_
+#define _fbtTables_h_
+
+#include "fbtTypes.h"
+
+/** \addtogroup FBT
+*  @{
+*/
+
+#define FBT_MAGIC 4
+
+namespace fbtIdNames
+{
+    const char FBT_SDNA[FBT_MAGIC] = {'S', 'D', 'N', 'A'};
+    const char FBT_NAME[FBT_MAGIC] = {'N', 'A', 'M', 'E'}; // Name array
+    const char FBT_TYPE[FBT_MAGIC] = {'T', 'Y', 'P', 'E'}; // Type Array
+    const char FBT_TLEN[FBT_MAGIC] = {'T', 'L', 'E', 'N'}; // Type length array
+    const char FBT_STRC[FBT_MAGIC] = {'S', 'T', 'R', 'C'}; // Struct/Class Array
+    const char FBT_OFFS[FBT_MAGIC] = {'O', 'F', 'F', 'S'}; // Offset map (Optional & TODO)
+}
+
+FBT_INLINE fbtFixedString<4> fbtByteToString(FBTuint32 i)
+{
+	union
+	{
+		char        ids[4];
+		FBTuint32   idi;
+	} IDU;
+	IDU.idi = i;
+	fbtFixedString<4> cp;
+	cp.push_back(IDU.ids[0]);
+	cp.push_back(IDU.ids[1]);
+	cp.push_back(IDU.ids[2]);
+	cp.push_back(IDU.ids[3]);
+	return cp;
+}
+
+
+typedef struct fbtName
+{
+	char*           m_name;     // note: memory is in the raw table.
+	int             m_loc;
+	FBTuint32       m_nameId;
+	int             m_ptrCount;
+	int             m_numSlots, m_isFptr;
+	int             m_arraySize;
+	int             m_slots[FBT_ARRAY_SLOTS];
+} fbtName;
+
+typedef struct fbtType
+{
+	char*           m_name;     // note: memory is in the raw table.
+	FBTuint32       m_typeId;	// fbtCharHashKey(typeName)
+	FBTuint32       m_strcId;	
+} fbtType;
+
+
+
+typedef union fbtKey32
+{
+	FBTint16 k16[2];
+	FBTint32 k32;
+} fbtKey32;
+
+typedef union fbtKey64
+{
+	FBTuint32 k32[2];
+	FBTuint64 k64;
+
+} fbtKey64;
+
+
+class fbtStruct
+{
+public:
+	typedef fbtArray<fbtStruct> Members;
+	typedef fbtArray<fbtKey64>  Keys;
+	
+	enum Flag
+	{
+		CAN_LINK    = 0,
+		MISSING     = (1 << 0),
+		MISALIGNED  = (1 << 1),
+		SKIP        = (1 << 2),
+		NEED_CAST	= (1 << 3)
+	};
+
+
+	fbtStruct()
+		:	m_key(),
+			m_val(),
+			m_off(0),
+			m_len(0),
+			m_nr(0),
+			m_dp(0),
+			m_strcId(0),
+			m_flag(0),
+			m_members(),
+			m_link(0)
+	{
+	}
+	~fbtStruct()    {}
+
+
+	fbtKey32        m_key;		//k[0]: type, k[1]: name
+	fbtKey64        m_val;		//key hash value, k[0]: type hash id, k[1]: member(field) base name hash id or 0(struct)
+	FBTint32        m_off;		//offset
+	FBTint32        m_len;
+	FBTint32        m_nr, m_dp; //nr: array index, dp: embeded depth
+	FBTint32        m_strcId;
+	FBTint32        m_flag;
+	Members         m_members;
+	fbtStruct*      m_link;		//file/memory table struct link
+	Keys            m_keyChain; //parent key hash chain(0: type hash, 1: name hash), size() == m_dp
+
+	FBTsizeType     getUnlinkedMemberCount();
+};
+
+
+class fbtBinTables
+{
+public:
+	typedef fbtName*                Names;  // < fbtMaxTable
+	typedef fbtType*                Types;  // < fbtMaxTable
+	typedef FBTtype*                TypeL;  // < fbtMaxTable
+	typedef FBTtype**               Strcs;  // < fbtMaxTable * fbtMaxMember;
+
+
+	// Base name trim (*[0-9]) for partial type, name matching
+	// Example: M(char m_var[32]) F(char m_var[24])
+	//
+	//          result = M(char m_var[24] = F(char m_var[24]) then (M(char m_var[24->32]) = 0)
+	//
+	// (Note: bParse will skip m_var all together because of 'strcmp(Mtype, Ftype) && strcmp(Mname, Fname)')
+	//
+	typedef fbtArray<FBTuint32>     NameB;
+	typedef fbtArray<fbtStruct*>    OffsM;
+
+	typedef fbtHashTable<fbtCharHashKey, fbtType> TypeFinder;
+
+public:
+
+	fbtBinTables();
+	fbtBinTables(void* ptr, const FBTsize& len);
+	~fbtBinTables();
+
+	bool read(bool swap);
+	bool read(const void* ptr, const FBTsize& len, bool swap);
+
+	FBTtype findTypeId(const fbtCharHashKey &cp);
+
+	const char* getStructType(const fbtStruct* strc);
+	const char* getStructName(const fbtStruct* strc);
+	const char* getOwnerStructName(const fbtStruct* strc);
+
+
+	Names   m_name;
+	Types   m_type;
+	TypeL   m_tlen;
+	Strcs   m_strc;
+	OffsM   m_offs;
+	NameB   m_base;
+
+	FBTuint32 m_nameNr;
+	FBTuint32 m_typeNr;
+	FBTuint32 m_strcNr;
+
+	// It's safe to assume that memory len is FBT_VOID and file len is FH_CHUNK_64 ? 8 : 4
+	// Othewise this library will not even compile (no more need for 'sizeof(ListBase) / 2')
+	FBTuint8    m_ptr;
+	void*       m_otherBlock;
+	FBTsize     m_otherLen;
+
+
+private:
+
+	TypeFinder m_typeFinder;
+
+	void putMember(FBTtype* cp, fbtStruct* off, FBTtype nr, FBTuint32& cof, FBTuint32 depth, fbtStruct::Keys& keys);
+	void compile(FBTtype i, FBTtype nr, fbtStruct* off, FBTuint32& cof, FBTuint32 depth, fbtStruct::Keys& keys);
+	void compile(void);
+	bool sikp(const FBTuint32& type);
+
+};
+
+
+/** @}*/
+#endif//_fbtTables_h_
Index: extern/FileTools/File/fbtTypes.cpp
===================================================================
--- extern/FileTools/File/fbtTypes.cpp	(revisione 0)
+++ extern/FileTools/File/fbtTypes.cpp	(revisione 0)
@@ -0,0 +1,210 @@
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Tables).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+#include "fbtTypes.h"
+
+
+#define FBT_IN_SOURCE
+#include "fbtPlatformHeaders.h"
+
+
+// ----------------------------------------------------------------------------
+// Debug Utilities
+
+
+#ifdef FBT_DEBUG
+bool fbtDebugger::isDebugger(void)
+{
+#if FBT_COMPILER == FBT_COMPILER_MSVC
+	return IsDebuggerPresent() != 0;
+#else
+	return false;
+#endif
+}
+
+void fbtDebugger::breakProcess(void)
+{
+#if FBT_COMPILER == FBT_COMPILER_MSVC
+	_asm int 3;
+#else
+	asm("int $3");
+#endif
+}
+
+#else//FBT_DEBUG
+
+
+bool fbtDebugger::isDebugger(void)
+{
+	return false;
+}
+
+void fbtDebugger::breakProcess(void)
+{
+}
+
+#endif//FBT_DEBUG
+
+
+#define FBT_DEBUG_BUF_SIZE (1024)
+fbtDebugger::Reporter fbtDebugger::m_report = {0, 0};
+
+
+void fbtDebugger::setReportHook(Reporter& hook)
+{
+	m_report.m_client = hook.m_client;
+	m_report.m_hook   = hook.m_hook;
+}
+
+
+void fbtDebugger::report(const char* fmt, ...)
+{
+	char ReportBuf[FBT_DEBUG_BUF_SIZE+1];
+
+	va_list lst;
+	va_start(lst, fmt);
+	int size = fbtp_printf(ReportBuf, FBT_DEBUG_BUF_SIZE, fmt, lst);
+	va_end(lst);
+
+	if (size < 0)
+	{
+		ReportBuf[FBT_DEBUG_BUF_SIZE] = 0;
+		size = FBT_DEBUG_BUF_SIZE;
+	}
+
+	if (size > 0)
+	{
+		ReportBuf[size] = 0;
+
+		if (m_report.m_hook)
+		{
+#if FBT_COMPILER == FBT_COMPILER_MSVC
+			if (IsDebuggerPresent())
+				OutputDebugString(ReportBuf);
+
+#endif
+			m_report.m_hook(m_report.m_client, ReportBuf);
+		}
+		else
+		{
+
+#if FBT_COMPILER == FBT_COMPILER_MSVC
+			if (IsDebuggerPresent())
+				OutputDebugString(ReportBuf);
+			else
+#endif
+				fprintf(stderr, "%s", ReportBuf);
+		}
+	}
+
+}
+
+
+void fbtDebugger::reportIDE(const char* src, long line, const char* fmt, ...)
+{
+	static char ReportBuf[FBT_DEBUG_BUF_SIZE+1];
+
+	va_list lst;
+	va_start(lst, fmt);
+
+
+	int size = fbtp_printf(ReportBuf, FBT_DEBUG_BUF_SIZE, fmt, lst);
+	va_end(lst);
+
+	if (size < 0)
+	{
+		ReportBuf[FBT_DEBUG_BUF_SIZE] = 0;
+		size = FBT_DEBUG_BUF_SIZE;
+	}
+
+	if (size > 0)
+	{
+		ReportBuf[size] = 0;
+#if FBT_COMPILER == FBT_COMPILER_MSVC
+		report("%s(%i): warning: %s", src, line, ReportBuf);
+#else
+		report("%s:%i: warning: %s", src, line, ReportBuf);
+#endif
+	}
+}
+
+
+void fbtDebugger::errorIDE(const char* src, long line, const char* fmt, ...)
+{
+	static char ReportBuf[FBT_DEBUG_BUF_SIZE+1];
+
+	va_list lst;
+	va_start(lst, fmt);
+
+
+	int size = fbtp_printf(ReportBuf, FBT_DEBUG_BUF_SIZE, fmt, lst);
+	va_end(lst);
+
+	if (size < 0)
+	{
+		ReportBuf[FBT_DEBUG_BUF_SIZE] = 0;
+		size = FBT_DEBUG_BUF_SIZE;
+	}
+
+	if (size > 0)
+	{
+		ReportBuf[size] = 0;
+#if FBT_COMPILER == FBT_COMPILER_MSVC
+		report("%s(%i): error: %s", src, line, ReportBuf);
+#else
+		report("%s:%i: error: %s", src, line, ReportBuf);
+#endif
+	}
+}
+
+FBT_PRIM_TYPE fbtGetPrimType(FBTuint32 typeKey)
+{
+	static FBTuint32 charT    = fbtCharHashKey("char").hash();
+	static FBTuint32 ucharT   = fbtCharHashKey("uchar").hash();
+	static FBTuint32 shortT   = fbtCharHashKey("short").hash();
+	static FBTuint32 ushortT  = fbtCharHashKey("ushort").hash();
+	static FBTuint32 intT     = fbtCharHashKey("int").hash();
+	static FBTuint32 longT    = fbtCharHashKey("long").hash();
+	static FBTuint32 ulongT   = fbtCharHashKey("ulong").hash();
+	static FBTuint32 floatT   = fbtCharHashKey("float").hash();
+	static FBTuint32 doubleT  = fbtCharHashKey("double").hash();
+	static FBTuint32 voidT    = fbtCharHashKey("void").hash();
+
+	if (typeKey == charT)	return FBT_PRIM_CHAR;
+	if (typeKey == ucharT)	return FBT_PRIM_UCHAR;
+	if (typeKey == shortT)	return FBT_PRIM_SHORT;
+	if (typeKey == ushortT)	return FBT_PRIM_USHORT;
+	if (typeKey == intT)	return FBT_PRIM_INT;
+	if (typeKey == longT)	return FBT_PRIM_LONG;
+	if (typeKey == ulongT)	return FBT_PRIM_ULONG;
+	if (typeKey == floatT)	return FBT_PRIM_FLOAT;
+	if (typeKey == doubleT)	return FBT_PRIM_DOUBLE;
+	if (typeKey == voidT)	return FBT_PRIM_VOID;
+
+	return FBT_PRIM_UNKNOWN;
+}
+
+
+
Index: extern/FileTools/File/fbtTypes.h
===================================================================
--- extern/FileTools/File/fbtTypes.h	(revisione 0)
+++ extern/FileTools/File/fbtTypes.h	(revisione 0)
@@ -0,0 +1,1542 @@
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Tables).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+#ifndef _fbtTypes_h_
+#define _fbtTypes_h_
+
+#ifndef FBT_HAVE_CONFIG
+#include "fbtConfig.h"
+#endif
+
+#include <string.h> //memcmp
+
+
+/** \addtogroup FBT
+*  @{
+*/
+
+#if (defined(DEBUG) || defined(_DEBUG)) && FBT_USE_DEBUG_ASSERTS == 1
+# include <assert.h> // Keep this the only std include in headers
+# define FBT_DEBUG 1
+# define FBT_ASSERT(x) assert(x)
+#else
+# define FBT_ASSERT(x) ((void)0)
+#endif
+
+#ifdef FBT_USE_COMPILER_CHECKS
+#define FBT_ASSERTCOMP(x, n) typedef bool x[(n) ? 1 : -1];
+#else
+#define FBT_ASSERTCOMP(x, n)
+#endif
+
+
+#define FBT_PLATFORM_WIN32    0
+#define FBT_PLATFORM_LINUX    2
+#define FBT_PLATFORM_APPLE    3
+
+#if defined (_WIN32)
+# define FBT_PLATFORM FBT_PLATFORM_WIN32
+#elif defined(__APPLE__)
+# define FBT_PLATFORM FBT_PLATFORM_APPLE
+#else
+# define FBT_PLATFORM FBT_PLATFORM_LINUX
+#endif
+
+#define FBT_COMPILER_MSVC    0
+#define FBT_COMPILER_GNU     1
+
+#if defined(_MSC_VER)
+# define FBT_COMPILER FBT_COMPILER_MSVC
+#elif defined(__GNUC__)
+# define FBT_COMPILER FBT_COMPILER_GNU
+#else
+# error unknown compiler
+#endif
+
+#define FBT_ENDIAN_LITTLE    0
+#define FBT_ENDIAN_BIG       1
+
+#if defined(__sgi)      ||  defined (__sparc)        || \
+    defined (__sparc__) ||  defined (__PPC__)        || \
+    defined (__ppc__)   ||  defined (__BIG_ENDIAN__)
+#define FBT_ENDIAN FBT_ENDIAN_BIG
+#else
+#define FBT_ENDIAN FBT_ENDIAN_LITTLE
+#endif
+
+#if FBT_ENDIAN == FBT_ENDIAN_BIG
+# define FBT_ID(a,b,c,d) ( (int)(a)<<24 | (int)(b)<<16 | (c)<<8 | (d) )
+# define FBT_ID2(c, d)   ( (c)<<8 | (d) )
+#else
+# define FBT_ID(a,b,c,d) ( (int)(d)<<24 | (int)(c)<<16 | (b)<<8 | (a) )
+# define FBT_ID2(c, d)   ( (d)<<8 | (c) )
+#endif
+
+#define FBT_ARCH_32 0
+#define FBT_ARCH_64 1
+
+#if defined(__x86_64__)     || defined(_M_X64)      || \
+    defined(__powerpc64__)  || defined(__alpha__)   || \
+    defined(__ia64__)       || defined(__s390__)    || \
+    defined(__s390x__)
+#define FBT_ARCH FBT_ARCH_64
+#else
+#define FBT_ARCH FBT_ARCH_32
+#endif
+
+
+#if FBT_PLATFORM == FBT_PLATFORM_WIN32
+# if defined(__MINGW32__) || \
+     defined(__CYGWIN__)  || \
+     (defined (_MSC_VER) && _MSC_VER < 1300)
+#  define FBT_INLINE inline
+# else
+#  define FBT_INLINE __forceinline
+# endif
+#else
+#  define FBT_INLINE    inline
+#endif
+
+// Integer types
+typedef long            FBTlong;
+typedef unsigned long   FBTulong;
+typedef int             FBTint32;
+typedef unsigned int    FBTuint32;
+typedef short           FBTint16;
+typedef unsigned short  FBTuint16;
+typedef signed char     FBTint8;
+typedef unsigned char   FBTuint8;
+typedef unsigned char   FBTubyte;
+typedef signed char     FBTbyte;
+typedef bool            FBTint1;
+
+
+#if FBT_COMPILER == FBT_COMPILER_GNU
+typedef long long          FBTint64;
+typedef unsigned long long FBTuint64;
+#else
+typedef __int64          FBTint64;
+typedef unsigned __int64 FBTuint64;
+#endif
+
+// Arch dependent types
+
+#if FBT_ARCH == FBT_ARCH_64
+typedef FBTuint64   FBTuintPtr;
+typedef FBTint64    FBTintPtr;
+#else
+typedef FBTuint32   FBTuintPtr;
+typedef FBTint32    FBTintPtr;
+#endif
+
+typedef FBTuintPtr  FBTsize;
+
+
+// Type for arrays & tables (Always unsigned & 32bit)
+typedef FBTuint32       FBTsizeType;
+const   FBTuint32       FBT_NPOS = (FBTuint32) - 1;
+typedef FBTuint32       FBThash;
+typedef FBTuint16       FBTtype;
+
+
+FBT_ASSERTCOMP(FBTsizeType_NPOS_VALIDATE, FBT_NPOS == ((FBTuint32) - 1));
+
+#define _FBT_CACHE_LIMIT 999
+
+template <typename T> FBT_INLINE void    fbtSwap(T& a, T& b)                              { T t(a); a = b; b = t; }
+template <typename T> FBT_INLINE T       fbtMax(const T& a, const T& b)                   { return a < b ? b : a; }
+template <typename T> FBT_INLINE T       fbtMin(const T& a, const T& b)                   { return a < b ? a : b; }
+template <typename T> FBT_INLINE T       fbtClamp(const T& v, const T& a, const T& b)     { return v < a ? a : v > b ? b : v; }
+
+
+#define fbtMalloc(size)             ::malloc(size)
+#define fbtCalloc(size, len)        ::calloc(size, len)
+#define fbtFree(ptr)                ::free(ptr)
+#define fbtMemset                   ::memset
+#define fbtMemcpy                   ::memcpy
+#define fbtMemmove                  ::memmove
+#define fbtMemcmp                   ::memcmp
+
+
+
+class fbtDebugger
+{
+public:
+	typedef void (*ReportHook) (FBTuintPtr client, const char* buffer);
+
+	struct Reporter
+	{
+		FBTuintPtr m_client;
+		ReportHook m_hook;
+	};
+
+	static bool isDebugger(void);
+	static void reportIDE(const char* src, long line, const char* msg, ...);
+	static void errorIDE(const char* src, long line, const char* msg, ...);
+	static void report(const char* msg, ...);
+	static void breakProcess(void);
+
+	static void setReportHook(Reporter& hook);
+
+private:
+	static Reporter m_report;
+
+};
+
+#define fbtPrintf fbtDebugger::report
+#define fbtTRACE  fbtDebugger::reportIDE
+#define fbtERROR  fbtDebugger::errorIDE
+
+typedef enum fbtEndian
+{
+	FBT_ENDIAN_IS_BIG       = 0,
+	FBT_ENDIAN_IS_LITTLE    = 1,
+	FBT_ENDIAN_NATIVE,
+} fbtEndian;
+
+typedef union fbtEndianTest
+{
+	FBTbyte  bo[4];
+	FBTint32 test;
+} fbtEndianTest;
+
+
+
+FBT_INLINE fbtEndian fbtGetEndian(void)
+{
+	fbtEndianTest e;
+	e.test = FBT_ENDIAN_IS_LITTLE;
+	return static_cast<fbtEndian>(e.bo[0]);
+}
+
+
+FBT_INLINE bool fbtIsEndian(const fbtEndian& endian)
+{
+	fbtEndianTest e;
+	e.test = endian;
+	return static_cast<fbtEndian>(e.bo[0]) == endian;
+}
+
+FBT_INLINE FBTuint16 fbtSwap16(FBTuint16 in)
+{
+	return static_cast<FBTuint16>(((in & 0xFF00) >> 8) | ((in & 0x00FF) << 8));
+}
+
+FBT_INLINE FBTuint32 fbtSwap32(const FBTuint32& in)
+{
+	return (((in & 0xFF000000) >> 24) | ((in & 0x00FF0000) >> 8) | ((in & 0x0000FF00) << 8)  | ((in & 0x000000FF) << 24));
+}
+
+FBT_INLINE FBTint16 fbtSwap16(FBTint16 in)
+{
+	return fbtSwap16(static_cast<FBTuint16>(in));
+}
+
+FBT_INLINE FBTint32 fbtSwap32(const FBTint32& in)
+{
+	return fbtSwap32(static_cast<FBTuint32>(in));
+}
+
+
+FBT_INLINE FBTuint64 fbtSwap64(const FBTuint64& in)
+{
+	FBTuint64 r = 0;
+	const FBTubyte* src = reinterpret_cast<const FBTubyte*>(&in);
+	FBTubyte* dst = reinterpret_cast<FBTubyte*>(&r);
+
+	dst[0] = src[7];
+	dst[1] = src[6];
+	dst[2] = src[5];
+	dst[3] = src[4];
+	dst[4] = src[3];
+	dst[5] = src[2];
+	dst[6] = src[1];
+	dst[7] = src[0];
+	return r;
+}
+
+
+FBT_INLINE void fbtSwap16(FBTuint16* sp, FBTsize malen)
+{
+	FBTsizeType a2;
+	for (a2 = 0; a2 < malen; ++a2)
+	{
+		*sp = fbtSwap16(*sp);
+		++sp;	
+	}	
+}
+
+FBT_INLINE void fbtSwap32(FBTuint32* ip, FBTsize malen)
+{	 
+	FBTsizeType a2;
+	for (a2 = 0; a2 < malen; ++a2)
+	{
+		*ip = fbtSwap32(*ip);
+		++ip;
+	}
+}
+
+
+FBT_INLINE void fbtSwap64(FBTuint64* dp, FBTsize malen)
+{	 
+	FBTsizeType a2;
+	for (a2 = 0; a2 < malen; ++a2)
+	{
+		*dp = fbtSwap64(*dp);
+		++dp;
+	}
+}
+
+
+FBT_INLINE FBTint64 fbtSwap64(const FBTint64& in)
+{
+	return fbtSwap64(static_cast<FBTuint64>(in));
+}
+
+
+
+enum fbtPointerLen
+{
+	FBT_VOID  = sizeof(void*),
+	FBT_VOID4 = FBT_VOID == 4,
+	FBT_VOID8 = FBT_VOID == 8,
+};
+
+
+#if FBT_ARCH == FBT_ARCH_64
+FBT_ASSERTCOMP(FBT_VOID8_ASSERT, FBT_VOID8);
+#else
+FBT_ASSERTCOMP(FBT_VOID4_ASSERT, FBT_VOID4);
+#endif
+
+
+
+
+class fbtList
+{
+public:
+
+	struct Link
+	{
+		Link*   next;
+		Link*   prev;
+	};
+
+
+	Link*   first;
+	Link*   last;
+
+public:
+
+	fbtList() : first(0), last(0) {}
+	~fbtList() { clear(); }
+
+	void clear(void) { first = last = 0; }
+
+	void push_back(void* v)
+	{
+		Link* link = ((Link*)v);
+		if (!link)
+			return;
+
+		link->prev = last;
+		if (last)
+			last->next = link;
+
+		if (!first)
+			first = link;
+
+		last = link;
+	}
+};
+
+
+
+
+
+template <typename T>
+class fbtArrayIterator
+{
+public:
+	typedef typename T::Pointer             Iterator;
+	typedef typename T::ReferenceType       ValueType;
+	typedef typename T::ConstReferenceType  ConstValueType;
+
+protected:
+
+	mutable Iterator        m_iterator;
+	mutable FBTsizeType     m_cur;
+	mutable FBTsizeType     m_capacity;
+
+public:
+
+
+	fbtArrayIterator() : m_iterator(0), m_cur(0), m_capacity(0) {}
+	fbtArrayIterator(Iterator begin, FBTsizeType size) : m_iterator(begin), m_cur(0), m_capacity(size) {}
+	fbtArrayIterator(T& v) : m_iterator(v.ptr()), m_cur(0), m_capacity(v.size()) { }
+
+	~fbtArrayIterator() {}
+
+	FBT_INLINE bool           hasMoreElements(void) const { return m_iterator && m_cur < m_capacity; }
+	FBT_INLINE ValueType      getNext(void)               { FBT_ASSERT(hasMoreElements()); return m_iterator[m_cur++];  }
+	FBT_INLINE ConstValueType getNext(void) const         { FBT_ASSERT(hasMoreElements()); return m_iterator[m_cur++];  }
+	FBT_INLINE void           next(void) const            { FBT_ASSERT(hasMoreElements()); ++m_cur; }
+	FBT_INLINE ValueType      peekNext(void)              { FBT_ASSERT(hasMoreElements()); return m_iterator[m_cur]; }
+	FBT_INLINE ConstValueType peekNext(void) const        { FBT_ASSERT(hasMoreElements()); return m_iterator[m_cur]; }
+
+};
+
+template <typename T>
+class fbtArray
+{
+public:
+	typedef T*           Pointer;
+	typedef const T*     ConstPointer;
+
+	typedef T            ValueType;
+	typedef const T      ConstValueType;
+
+	typedef T&           ReferenceType;
+	typedef const T&     ConstReferenceType;
+
+	typedef fbtArrayIterator<fbtArray<T> >       Iterator;
+	typedef const fbtArrayIterator<fbtArray<T> > ConstIterator;
+
+public:
+	fbtArray() : m_size(0), m_capacity(0), m_data(0), m_cache(0)  {}
+
+	fbtArray(const fbtArray<T>& o)
+		: m_size(o.size()), m_capacity(0), m_data(0), m_cache(0)
+	{
+		reserve(m_size);
+		copy(m_data, o.m_data, m_size);
+	}
+
+	~fbtArray() { clear(); }
+
+	void clear(bool useCache = false)
+	{
+		if (!useCache)
+		{
+			if (m_data)
+				delete []m_data;
+			m_data = 0;
+			m_capacity = 0;
+			m_size = 0;
+			m_cache = 0;
+		}
+		else
+		{
+			++m_cache;
+			if (m_cache > _FBT_CACHE_LIMIT )
+				clear(false);
+			else m_size = 0;
+		}
+	}
+
+	FBTsizeType find(const T& v)
+	{
+		for (FBTsizeType i = 0; i < m_size; i++)
+		{
+			if (m_data[i] == v)
+				return i;
+		}
+		return FBT_NPOS;
+	}
+
+	FBT_INLINE void push_back(const T& v)
+	{
+		if (m_size == m_capacity)
+			reserve(m_size == 0 ? 8 : m_size * 2);
+
+		m_data[m_size] = v;
+		m_size++;
+	}
+
+	FBT_INLINE void pop_back(void)
+	{
+		m_size--;
+		m_data[m_size].~T();
+	}
+
+
+	void erase(const T& v)
+	{
+		erase(find(v));
+	}
+
+	void erase(FBTsizeType pos)
+	{
+		if (m_size > 0)
+		{
+			if (pos != FBT_NPOS)
+			{
+				swap(pos, m_size - 1);
+				m_size--;
+				m_data[m_size].~T();
+			}
+		}
+	}
+
+	void resize(FBTsizeType nr)
+	{
+		if (nr < m_size)
+		{
+			for (FBTsizeType i = m_size; i < nr; i++)
+				m_data[i].~T();
+		}
+		else
+		{
+			if (nr > m_size)
+				reserve(nr);
+		}
+		m_size = nr;
+	}
+
+	void resize(FBTsizeType nr, const T& fill)
+	{
+		if (nr < m_size)
+		{
+			for (FBTsizeType i = m_size; i < nr; i++)
+				m_data[i].~T();
+		}
+		else
+		{
+			if (nr > m_size)
+				reserve(nr);
+			for (FBTsizeType i = m_size; i < nr; i++)
+				m_data[i] = fill;
+
+		}
+		m_size = nr;
+	}
+
+	void reserve(FBTsizeType nr)
+	{
+
+		if (m_capacity < nr)
+		{
+			T* p = new T[nr];
+			if (m_data != 0)
+			{
+				copy(p, m_data, m_size);
+				delete []m_data;
+			}
+			m_data = p;
+			m_capacity = nr;
+		}
+	}
+
+	void sort(bool (*cmp)(const T& a, const T& b))
+	{
+		if (m_size > 1 && cmp)
+			_sort(cmp, 0, m_size - 1);
+	}
+
+	FBT_INLINE T& operator[](FBTsizeType idx)               { FBT_ASSERT(idx >= 0 && idx < m_capacity); return m_data[idx]; }
+	FBT_INLINE const T& operator[](FBTsizeType idx) const   { FBT_ASSERT(idx >= 0 && idx < m_capacity); return m_data[idx]; }
+	FBT_INLINE T& at(FBTsizeType idx)                       { FBT_ASSERT(idx >= 0 && idx < m_capacity); return m_data[idx]; }
+	FBT_INLINE const T& at(FBTsizeType idx) const           { FBT_ASSERT(idx >= 0 && idx < m_capacity); return m_data[idx]; }
+	FBT_INLINE T& front(void)                               { FBT_ASSERT(m_size > 0); return m_data[0]; }
+	FBT_INLINE T& back(void)                                { FBT_ASSERT(m_size > 0); return m_data[m_size-1]; }
+
+	FBT_INLINE ConstPointer ptr(void) const             { return m_data; }
+	FBT_INLINE Pointer      ptr(void)                   { return m_data; }
+	FBT_INLINE bool         valid(void) const           { return m_data != 0;}
+
+	FBT_INLINE FBTsizeType capacity(void) const         { return m_capacity; }
+	FBT_INLINE FBTsizeType size(void) const             { return m_size; }
+	FBT_INLINE bool empty(void) const                   { return m_size == 0;}
+
+	FBT_INLINE Iterator       iterator(void)       { return m_data && m_size > 0 ? Iterator(m_data, m_size) : Iterator(); }
+	FBT_INLINE ConstIterator  iterator(void) const { return m_data && m_size > 0 ? ConstIterator(m_data, m_size) : ConstIterator(); }
+
+	fbtArray<T> &operator= (const fbtArray<T> &rhs)
+	{
+		if (this != &rhs)
+		{
+			clear();
+			FBTsizeType os = rhs.size();
+			if (os > 0)
+			{
+				resize(os);
+				copy(m_data, rhs.m_data, os);
+			}
+		}
+
+		return *this;
+	}
+
+	FBT_INLINE void copy(Pointer dst, ConstPointer src, FBTsizeType size)
+	{
+		FBT_ASSERT(size <= m_size);
+		for (FBTsizeType i = 0; i < size; i++) dst[i] = src[i];
+	}
+
+	FBT_INLINE bool equal(const fbtArray<T> &rhs)
+	{
+		if (rhs.size() != size()) return false;
+		if (empty()) return true;
+		return fbtMemcmp(m_data, rhs.m_data, sizeof(T)*m_size) == 0;
+	}
+
+protected:
+
+	void _sort(bool (*cmp)(const T& a, const T& b), int lo, int hi)
+	{
+		// btAlignedObjectArray.h
+
+		int i = lo, j = hi;
+		T x = m_data[(lo+hi)/2];
+
+		//  partition
+		do
+		{
+			while (cmp(m_data[i], x))
+				i++;
+			while (cmp(x, m_data[j]))
+				j--;
+			if (i <= j)
+			{
+				swap(i, j);
+				i++; j--;
+			}
+		}
+		while (i <= j);
+
+		//  recursion
+		if (lo < j)
+			_sort( cmp, lo, j);
+		if (i < hi)
+			_sort( cmp, i, hi);
+	}
+
+
+	void swap(FBTsizeType a, FBTsizeType b)
+	{
+		ValueType t = m_data[a];
+		m_data[a] = m_data[b];
+		m_data[b] = t;
+	}
+
+	FBTsizeType     m_size;
+	FBTsizeType     m_capacity;
+	Pointer         m_data;
+	int             m_cache;
+};
+
+
+
+template <typename T>
+class fbtHashTableIterator
+{
+public:
+
+	typedef typename T::Pointer        Iterator;
+	typedef typename T::Entry&          Pair;
+	typedef typename T::ConstEntry&     ConstPair;
+
+	typedef typename T::ReferenceKeyType         KeyType;
+	typedef typename T::ReferenceValueType       ValueType;
+	typedef typename T::ConstReferenceKeyType    ConstKeyType;
+	typedef typename T::ConstReferenceValueType  ConstValueType;
+
+protected:
+
+	mutable Iterator m_iterator;
+	mutable FBTsizeType   m_cur;
+	const FBTsizeType     m_capacity;
+
+
+public:
+	fbtHashTableIterator() : m_iterator(0), m_cur(0), m_capacity(0)  {}
+	fbtHashTableIterator(Iterator begin, FBTsizeType size) : m_iterator(begin), m_cur(0), m_capacity(size) { }
+	fbtHashTableIterator(T& v) : m_iterator(v.ptr()), m_cur(0), m_capacity(v.size()) {}
+
+	~fbtHashTableIterator() {}
+
+	FBT_INLINE bool      hasMoreElements(void) const  { return (m_iterator && m_cur < m_capacity); }
+	FBT_INLINE Pair      getNext(void)                { FBT_ASSERT(hasMoreElements()); return m_iterator[m_cur++];}
+	FBT_INLINE ConstPair getNext(void) const          { FBT_ASSERT(hasMoreElements()); return m_iterator[m_cur++];}
+	FBT_INLINE void      next(void) const             { FBT_ASSERT(hasMoreElements()); ++m_cur; }
+
+
+	FBT_INLINE Pair      peekNext(void)               { FBT_ASSERT(hasMoreElements()); return m_iterator[m_cur]; }
+	FBT_INLINE KeyType   peekNextKey(void)            { FBT_ASSERT(hasMoreElements()); return m_iterator[m_cur].first;}
+	FBT_INLINE ValueType peekNextValue(void)          { FBT_ASSERT(hasMoreElements()); return m_iterator[m_cur].second; }
+
+	FBT_INLINE ConstPair      peekNext(void)  const     { FBT_ASSERT(hasMoreElements()); return m_iterator[m_cur]; }
+	FBT_INLINE ConstKeyType   peekNextKey(void) const   { FBT_ASSERT(hasMoreElements()); return m_iterator[m_cur].first;}
+	FBT_INLINE ConstValueType peekNextValue(void) const { FBT_ASSERT(hasMoreElements()); return m_iterator[m_cur].second; }
+};
+
+
+
+// magic numbers from http://www.isthe.com/chongo/tech/comp/fnv/
+#define _FBT_INITIAL_FNV  0x9E3779B1
+#define _FBT_INITIAL_FNV2 0x9E3779B9
+#define _FBT_MULTIPLE_FNV 0x1000193
+#define _FBT_TWHASH(key)         \
+        key += ~(key << 15);    \
+        key ^=  (key >> 10);    \
+        key +=  (key << 3);     \
+        key ^=  (key >> 6);     \
+        key += ~(key << 11);    \
+        key ^=  (key >> 16);
+
+
+class fbtCharHashKey
+{
+protected:
+	char* m_key;
+	mutable FBThash m_hash;
+
+public:
+	fbtCharHashKey() : m_key(0), m_hash(FBT_NPOS) {}
+	fbtCharHashKey(char* k) : m_key(k), m_hash(FBT_NPOS) {hash();}
+	fbtCharHashKey(const char* k) : m_key(const_cast<char*>(k)), m_hash(FBT_NPOS) {}
+	fbtCharHashKey(const fbtCharHashKey& k) : m_key(k.m_key), m_hash(k.m_hash) { if (m_hash == FBT_NPOS) hash(); }
+
+
+	FBThash hash(void) const
+	{
+		if (!m_key) return FBT_NPOS;
+		if (m_hash != FBT_NPOS) return m_hash;
+
+		// Fowler / Noll / Vo (FNV) Hash
+		m_hash = (FBThash)_FBT_INITIAL_FNV;
+		for (int i = 0; m_key[i]; i++)
+		{
+			m_hash = m_hash ^ (m_key[i]);   // xor  the low 8 bits
+			m_hash = m_hash * _FBT_MULTIPLE_FNV;  // multiply by the magic number
+		}
+		return m_hash;
+	}
+
+	FBT_INLINE bool operator== (const fbtCharHashKey& v) const    {return hash() == v.hash();}
+	FBT_INLINE bool operator!= (const fbtCharHashKey& v) const    {return hash() != v.hash();}
+	FBT_INLINE bool operator== (const FBThash& v) const           {return hash() == v;}
+	FBT_INLINE bool operator!= (const FBThash& v) const           {return hash() != v;}
+};
+
+class fbtIntHashKey
+{
+protected:
+	FBTint32 m_key;
+public:
+	fbtIntHashKey() : m_key(0) {}
+	fbtIntHashKey(FBTint32 k) : m_key(k) {}
+	fbtIntHashKey(const fbtIntHashKey& k) : m_key(k.m_key) { }
+
+	FBT_INLINE FBThash hash(void) const  { return static_cast<FBThash>(m_key) * _FBT_INITIAL_FNV; }
+
+	FBT_INLINE bool operator== (const fbtIntHashKey& v) const {return hash() == v.hash();}
+	FBT_INLINE bool operator!= (const fbtIntHashKey& v) const {return hash() != v.hash();}
+	FBT_INLINE bool operator== (const FBThash& v) const       {return hash() == v;}
+	FBT_INLINE bool operator!= (const FBThash& v) const       {return hash() != v;}
+};
+
+
+
+//For handing invalid pointers
+class fbtSizeHashKey
+{
+protected:
+
+	FBTsize m_key;
+	mutable FBThash m_hash;
+
+public:
+	fbtSizeHashKey()
+		: m_hash(FBT_NPOS), m_key(0)
+	{
+	}
+
+
+	fbtSizeHashKey(const FBTsize& k)
+		:   m_hash(FBT_NPOS), m_key(k)
+	{
+		hash();
+	}
+
+
+	fbtSizeHashKey(const fbtSizeHashKey& k)
+		:   m_hash(FBT_NPOS), m_key(k.m_key)
+	{
+		hash();
+	}
+
+
+	FBT_INLINE FBThash hash(void) const
+	{
+		if (m_hash != FBT_NPOS)
+			return m_hash;
+
+		m_hash = (FBThash)m_key;
+		_FBT_TWHASH(m_hash);
+		return m_hash;
+	}
+
+	FBT_INLINE bool operator== (const fbtSizeHashKey& v) const  { return hash() == v.hash();}
+	FBT_INLINE bool operator!= (const fbtSizeHashKey& v) const  { return hash() != v.hash();}
+	FBT_INLINE bool operator== (const FBThash& v) const         { return hash() == v;}
+	FBT_INLINE bool operator!= (const FBThash& v) const         { return hash() != v;}
+};
+
+
+template<typename T>
+class fbtTHashKey
+{
+protected:
+	T* m_key;
+	mutable FBThash m_hash;
+
+public:
+	fbtTHashKey() : m_key(0), m_hash(FBT_NPOS) { hash(); }
+	fbtTHashKey(T* k) : m_key(k), m_hash(FBT_NPOS) { hash(); }
+	fbtTHashKey(const fbtTHashKey& k) : m_key(k.m_key), m_hash(k.m_hash) { if (m_hash == FBT_NPOS) hash(); }
+
+	FBT_INLINE T*          key(void)       {return m_key;}
+	FBT_INLINE const T*    key(void) const {return m_key;}
+
+
+	FBT_INLINE FBThash hash(void) const
+	{
+		if (m_hash != FBT_NPOS)
+			return m_hash;
+
+		// Yields the least collisions.
+		m_hash = static_cast<FBThash>(reinterpret_cast<FBTuintPtr>(m_key));
+		_FBT_TWHASH(m_hash);
+		return m_hash;
+	}
+
+
+	FBT_INLINE bool operator== (const fbtTHashKey& v) const  { return hash() == v.hash();}
+	FBT_INLINE bool operator!= (const fbtTHashKey& v) const  { return hash() != v.hash();}
+	FBT_INLINE bool operator== (const FBThash& v) const      { return hash() == v;}
+	FBT_INLINE bool operator!= (const FBThash& v) const      { return hash() != v;}
+};
+
+typedef fbtTHashKey<void> fbtPointerHashKey;
+
+
+template<typename Key, typename Value>
+struct fbtHashEntry
+{
+	Key    first;
+	Value  second;
+
+	fbtHashEntry() {}
+	fbtHashEntry(const Key& k, const Value& v) : first(k), second(v) {}
+
+	FBT_INLINE bool operator==(const fbtHashEntry& rhs) const
+	{
+		return first == rhs.first && second == rhs.second;
+	}
+};
+
+#define _FBT_UTHASHTABLE_HASH(key)      ((key.hash() & (m_capacity - 1)))
+#define _FBT_UTHASHTABLE_HKHASH(key)    ((hk & (m_capacity - 1)))
+#define _FBT_UTHASHTABLE_FORCE_POW2     1
+#define _FBT_UTHASHTABLE_INIT           32
+#define _FBT_UTHASHTABLE_EXPANSE  (m_size * 2)
+
+
+#define _FBT_UTHASHTABLE_STAT       FBT_HASHTABLE_STAT
+#define _FBT_UTHASHTABLE_STAT_ALLOC 0
+
+
+#if _FBT_UTHASHTABLE_FORCE_POW2 == 1
+#define _FBT_UTHASHTABLE_POW2(x) \
+    --x; x |= x >> 16; x |= x >> 8; x |= x >> 4; \
+    x |= x >> 2; x |= x >> 1; ++x;
+
+#define _FBT_UTHASHTABLE_IS_POW2(x) (x && !((x-1) & x))
+#endif
+
+
+#if _FBT_UTHASHTABLE_STAT == 1
+#include <typeinfo>
+#endif
+
+
+
+template < typename Key, typename Value >
+class fbtHashTable
+{
+public:
+	typedef fbtHashEntry<Key, Value>        Entry;
+	typedef const fbtHashEntry<Key, Value>  ConstEntry;
+
+	typedef Entry*  EntryArray;
+	typedef FBTsizeType* IndexArray;
+
+
+	typedef Key            KeyType;
+	typedef Value          ValueType;
+
+	typedef const Key      ConstKeyType;
+	typedef const Value    ConstValueType;
+
+	typedef Value&          ReferenceValueType;
+	typedef const Value&    ConstReferenceValueType;
+
+	typedef Key&            ReferenceKeyType;
+	typedef const Key&      ConstReferenceKeyType;
+
+	typedef EntryArray Pointer;
+	typedef const Entry* ConstPointer;
+
+
+	typedef fbtHashTableIterator<fbtHashTable<Key, Value> > Iterator;
+	typedef const fbtHashTableIterator<fbtHashTable<Key, Value> > ConstIterator;
+
+
+public:
+
+	fbtHashTable()
+		:    m_size(0), m_capacity(0), m_lastPos(FBT_NPOS),
+		     m_iptr(0), m_nptr(0), m_bptr(0), m_cache(0)
+	{
+	}
+
+	fbtHashTable(FBTsizeType capacity)
+		:    m_size(0), m_capacity(0), m_lastPos(FBT_NPOS),
+		     m_iptr(0), m_nptr(0), m_bptr(0), m_cache(0)
+	{
+	}
+
+	fbtHashTable(const fbtHashTable& rhs)
+		:    m_size(0), m_capacity(0), m_lastPos(FBT_NPOS),
+		     m_iptr(0), m_nptr(0), m_bptr(0), m_cache(0)
+	{
+		doCopy(rhs);
+	}
+
+	~fbtHashTable() { clear(); }
+
+	fbtHashTable<Key, Value> &operator = (const fbtHashTable<Key, Value> &rhs)
+	{
+		if (this != &rhs)
+			doCopy(rhs);
+		return *this;
+	}
+
+	void clear(bool useCache = false)
+	{
+		if (!useCache)
+		{
+			m_size = m_capacity = 0;
+			m_lastKey = FBT_NPOS;
+			m_lastPos = FBT_NPOS;
+			m_cache = 0;
+
+			delete [] m_bptr;
+			delete [] m_iptr;
+			delete [] m_nptr;
+			m_bptr = 0; m_iptr = 0; m_nptr = 0;
+		}
+		else
+		{
+			++m_cache;
+			if (m_cache > _FBT_CACHE_LIMIT)
+				clear(false);
+			else
+			{
+				m_size = 0;
+				m_lastKey = FBT_NPOS;
+				m_lastPos = FBT_NPOS;
+
+
+				FBTsizeType i;
+				for (i = 0; i < m_capacity; ++i)
+				{
+					m_iptr[i] = FBT_NPOS;
+					m_nptr[i] = FBT_NPOS;
+				}
+			}
+		}
+
+	}
+	Value&              at(FBTsizeType i)                    { FBT_ASSERT(m_bptr && i >= 0 && i < m_size); return m_bptr[i].second; }
+	Value&              operator [](FBTsizeType i)           { FBT_ASSERT(m_bptr && i >= 0 && i < m_size); return m_bptr[i].second; }
+	const Value&        at(FBTsizeType i)const               { FBT_ASSERT(m_bptr && i >= 0 && i < m_size); return m_bptr[i].second; }
+	const Value&        operator [](FBTsizeType i) const     { FBT_ASSERT(m_bptr && i >= 0 && i < m_size); return m_bptr[i].second; }
+	Key&                keyAt(FBTsizeType i)                 { FBT_ASSERT(m_bptr && i >= 0 && i < m_size); return m_bptr[i].first; }
+	const Key&          keyAt(FBTsizeType i)const            { FBT_ASSERT(m_bptr && i >= 0 && i < m_size); return m_bptr[i].first; }
+
+	Value* get(const Key& key) const
+	{
+		if (!m_bptr || m_size == 0)
+			return (Value*)0;
+
+
+		FBThash hr = key.hash();
+
+		if (m_lastKey != hr)
+		{
+			FBTsizeType i = find(key);
+			if (i == FBT_NPOS) return (Value*)0;
+
+
+			FBT_ASSERT(i >= 0 && i < m_size);
+
+			m_lastKey = hr;
+			m_lastPos = i;
+		}
+
+		return &m_bptr[m_lastPos].second;
+	}
+
+
+	Value*         operator [](const Key& key)       { return get(key); }
+	const Value*   operator [](const Key& key) const { return get(key); }
+
+	FBTsizeType find(const Key& key) const
+	{
+		if (m_capacity == 0 || m_capacity == FBT_NPOS || m_size == 0)
+			return FBT_NPOS;
+
+		FBTsizeType hk = key.hash();
+		if (m_lastPos != FBT_NPOS && m_lastKey == hk)
+			return m_lastPos;
+
+		FBThash hr = _FBT_UTHASHTABLE_HKHASH(hk);
+
+		FBT_ASSERT(m_bptr && m_iptr && m_nptr);
+
+		FBTsizeType fh = m_iptr[hr];
+		while (fh != FBT_NPOS && (key != m_bptr[fh].first))
+			fh = m_nptr[fh];
+
+
+		if (fh != FBT_NPOS)
+		{
+			m_lastKey = hk;
+			m_lastPos = fh;
+
+			FBT_ASSERT(fh >= 0  && fh < m_size);
+		}
+		return fh;
+	}
+
+
+
+	void erase(const Key& key) {remove(key);}
+
+	void remove(const Key& key)
+	{
+		FBThash hash, lhash;
+		FBTsizeType index, pindex, findex;
+
+		findex = find(key);
+		if (findex == FBT_NPOS || m_capacity == 0 || m_size == 0)
+			return;
+
+		m_lastKey = FBT_NPOS;
+		m_lastPos = FBT_NPOS;
+		FBT_ASSERT(m_bptr && m_iptr && m_nptr);
+
+		hash = _FBT_UTHASHTABLE_HASH(key);
+
+		index  = m_iptr[hash];
+		pindex = FBT_NPOS;
+		while (index != findex)
+		{
+			pindex = index;
+			index = m_nptr[index];
+		}
+
+		if (pindex != FBT_NPOS)
+		{
+			FBT_ASSERT(m_nptr[pindex] == findex);
+			m_nptr[pindex] = m_nptr[findex];
+		}
+		else
+			m_iptr[hash] = m_nptr[findex];
+
+		FBTsizeType lindex = m_size - 1;
+		if (lindex == findex)
+		{
+			--m_size;
+			m_bptr[m_size].~Entry();
+			return;
+		}
+
+		lhash = _FBT_UTHASHTABLE_HASH(m_bptr[lindex].first);
+		index  = m_iptr[lhash];
+		pindex = FBT_NPOS;
+		while (index != lindex)
+		{
+			pindex = index;
+			index = m_nptr[index];
+		}
+
+		if (pindex != FBT_NPOS)
+		{
+			FBT_ASSERT(m_nptr[pindex] == lindex);
+			m_nptr[pindex] = m_nptr[lindex];
+		}
+		else
+			m_iptr[lhash] = m_nptr[lindex];
+
+		m_bptr[findex] = m_bptr[lindex];
+		m_nptr[findex] = m_iptr[lhash];
+		m_iptr[lhash] = findex;
+
+		--m_size;
+		m_bptr[m_size].~Entry();
+		return;
+	}
+
+	bool insert(const Key& key, const Value& val)
+	{
+		if (find(key) != FBT_NPOS)
+			return false;
+
+		if (m_size == m_capacity)
+			reserve(m_size == 0 ? _FBT_UTHASHTABLE_INIT : _FBT_UTHASHTABLE_EXPANSE);
+
+		const FBThash hr = _FBT_UTHASHTABLE_HASH(key);
+
+		FBT_ASSERT(m_bptr && m_iptr && m_nptr);
+		m_bptr[m_size] = Entry(key, val);
+		m_nptr[m_size] = m_iptr[hr];
+		m_iptr[hr] = m_size;
+		++m_size;
+		return true;
+	}
+
+	FBT_INLINE Pointer ptr(void)                { return m_bptr; }
+	FBT_INLINE ConstPointer ptr(void) const     { return m_bptr; }
+	FBT_INLINE bool valid(void) const           { return m_bptr != 0;}
+
+
+	FBT_INLINE FBTsizeType size(void) const         { return m_size; }
+	FBT_INLINE FBTsizeType capacity(void) const     { return capacity; }
+	FBT_INLINE bool empty(void) const               { return m_size == 0; }
+
+
+	Iterator        iterator(void)       { return m_bptr && m_size > 0 ? Iterator(m_bptr, m_size) : Iterator(); }
+	ConstIterator   iterator(void) const { return m_bptr && m_size > 0 ? ConstIterator(m_bptr, m_size) : ConstIterator(); }
+
+
+	void reserve(FBTsizeType nr)
+	{
+		if (m_capacity < nr && nr != FBT_NPOS)
+			rehash(nr);
+	}
+
+#if _FBT_UTHASHTABLE_STAT == 1
+
+	void report(void) const
+	{
+		if (m_capacity == 0 || m_capacity == FBT_NPOS || m_size == 0)
+			return;
+
+		FBT_ASSERT(m_bptr && m_iptr && m_nptr);
+
+
+		FBTsizeType min_col = m_size, max_col = 0;
+		FBTsizeType i, tot = 0, avg = 0;
+		for (i = 0; i < m_size; ++i)
+		{
+			Key& key = m_bptr[i].first;
+
+			FBThash hr = _FBT_UTHASHTABLE_HASH(key);
+
+			FBTsizeType nr = 0;
+
+			FBTsizeType fh = m_iptr[hr];
+			while (fh != FBT_NPOS && (key != m_bptr[fh].first))
+			{
+				fh = m_nptr[fh];
+				nr++;
+			}
+
+			if (nr < min_col)
+				min_col = nr;
+			if (nr > max_col)
+				max_col = nr;
+
+			tot += nr;
+			avg += nr ? 1 : 0;
+		}
+
+#if _FBT_UTHASHTABLE_FORCE_POW2 == 1
+		fbtPrintf("Results using forced power of 2 expansion.\n\n");
+#else
+		fbtPrintf("Results using unaltered expansion.\n\n");
+#endif
+		fbtPrintf("\tTotal number of collisions %i for a table of size %i.\n\t\tusing (%s)\n", tot, m_size, typeid(Key).name());
+		fbtPrintf("\tThe minimum number of collisions per key: %i\n", min_col);
+		fbtPrintf("\tThe maximum number of collisions per key: %i\n", max_col);
+
+		int favr = (int)(100.f * ((float)avg / (float)m_size));
+		fbtPrintf("\tThe average number of key collisions: %i\n\n", favr);
+
+		if (tot == 0)
+			fbtPrintf("\nCongratulations lookup is 100%% linear!\n\n");
+		else if (favr >  35)
+			fbtPrintf("\nImprove your hash function!\n\n");
+	}
+#endif
+
+
+
+private:
+
+	void doCopy(const fbtHashTable<Key, Value> &rhs)
+	{
+		if (rhs.valid() && !rhs.empty())
+		{
+			reserve(rhs.m_capacity);
+
+			FBTsizeType i, b;
+			m_size     = rhs.m_size;
+			m_capacity = rhs.m_capacity;
+
+			b = m_size > 0 ? m_size - 1 : 0;
+			for (i = b; i < m_capacity; ++i) m_nptr[i] = m_iptr[i] = FBT_NPOS;
+
+			for (i = 0; i < m_size; ++i)
+			{
+				m_bptr[i] = rhs.m_bptr[i];
+				m_iptr[i] = rhs.m_iptr[i];
+				m_nptr[i] = rhs.m_nptr[i];
+			}
+		}
+
+	}
+
+	template<typename ArrayType>
+	void reserveType(ArrayType** old, FBTsizeType nr, bool cpy = false)
+	{
+		FBTsizeType i;
+		ArrayType* nar = new ArrayType[nr];
+		if ((*old) != 0)
+		{
+			if (cpy)
+			{
+				const ArrayType* oar = (*old);
+				for (i = 0; i < m_size; i++) nar[i] = oar[i];
+			}
+			delete [](*old);
+		}
+		(*old) = nar;
+	}
+
+
+	void rehash(FBTsizeType nr)
+	{
+#if _FBT_UTHASHTABLE_FORCE_POW2
+
+		if (!_FBT_UTHASHTABLE_IS_POW2(nr))
+		{
+			_FBT_UTHASHTABLE_POW2(nr);
+		}
+
+#if _FBT_UTHASHTABLE_STAT_ALLOC == 1
+		fbtPrintf("Expanding tables: %i\n", nr);
+#endif
+		FBT_ASSERT(_FBT_UTHASHTABLE_IS_POW2(nr));
+
+
+#else
+
+#if _FBT_UTHASHTABLE_STAT_ALLOC == 1
+		fbtPrintf("Expanding tables: %i\n", nr);
+#endif
+
+#endif
+
+		reserveType<Entry>(&m_bptr, nr, true);
+		reserveType<FBTsizeType>(&m_iptr, nr);
+		reserveType<FBTsizeType>(&m_nptr, nr);
+
+		m_capacity = nr;
+		FBT_ASSERT(m_bptr && m_iptr && m_nptr);
+
+
+		FBTsizeType i, h;
+		for (i = 0; i < m_capacity; ++i) { m_iptr[i] = m_nptr[i] = FBT_NPOS; }
+		for (i = 0; i < m_size; i++)     { h = _FBT_UTHASHTABLE_HASH(m_bptr[i].first); m_nptr[i] = m_iptr[h]; m_iptr[h] = i;}
+	}
+
+
+
+	FBTsizeType m_size, m_capacity;
+	mutable FBTsizeType m_lastPos;
+	mutable FBTsizeType m_lastKey;
+
+	IndexArray m_iptr;
+	IndexArray m_nptr;
+	EntryArray m_bptr;
+	FBTsizeType m_cache;
+};
+
+
+
+
+#define fbtCharNEq(a, b, n)  ((a && b) && !strncmp(a, b, n))
+#define fbtCharEq(a, b)      ((a && b) && (*a == *b) && !strcmp(a, b))
+#define fbtCharEqL(a, b, l)  ((a && b) && (*a == *b) && !memcmp(a, b, l))
+
+FBT_INLINE int fbtStrLen(const char* cp)
+{
+	int i = 0;
+	while (cp[i]) cp[i++];
+	return i;
+}
+
+
+// For operations on a fixed size character array
+template <const FBTuint16 L>
+class fbtFixedString
+{
+public:
+	typedef char Pointer[L+1];
+
+
+public:
+
+	fbtFixedString()
+		: m_size(0), m_hash(FBT_NPOS)
+	{
+		m_buffer[m_size] = 0;
+	}
+
+	fbtFixedString(const fbtFixedString& rhs)
+		:   m_size(0), m_hash(FBT_NPOS)
+	{
+		if (rhs.size())
+		{
+			FBTuint16 i, os = rhs.size();
+			const char* cp = rhs.c_str();
+
+			for (i = 0; i < L && i < os; ++i, ++m_size) m_buffer[i] = cp[i];
+		}
+		m_buffer[m_size] = 0;
+	}
+
+
+	fbtFixedString(const char* rhs)
+		:   m_size(0), m_hash(FBT_NPOS)
+	{
+		if (rhs)
+		{
+			FBTuint16 i;
+			for (i = 0; i < L && rhs[i]; ++i, ++m_size) m_buffer[i] = rhs[i];
+		}
+		m_buffer[m_size] = 0;
+	}
+
+
+
+	FBT_INLINE void push_back(char ch)
+	{
+		if (m_size >= L)
+			return;
+		m_buffer[m_size++] = ch;
+		m_buffer[m_size] = 0;
+	}
+
+	void append(const char* str)
+	{
+		int len = fbtStrLen(str);
+		int a = 0;
+		while (a < len)
+			push_back(str[a++]);
+	}
+
+
+	void append(const fbtFixedString& str)
+	{
+		int len = str.m_size;
+		int a = 0;
+		while (a < len)
+			push_back(str.m_buffer[a++]);
+	}
+
+
+	fbtFixedString operator +(const fbtFixedString& rhs)
+	{
+		fbtFixedString lhs = *this;
+		lhs.append(rhs);
+		return lhs;
+	}
+
+
+	fbtFixedString operator +=(const fbtFixedString& rhs)
+	{
+		append(rhs);
+		return *this;
+	}
+
+	fbtFixedString operator +(const char* str)
+	{
+		fbtFixedString lhs = *this;
+		lhs.append(str);
+		return lhs;
+	}
+
+	fbtFixedString operator +=(const char* str)
+	{
+		append(str);
+		return *this;
+	}
+
+
+	void split(fbtArray<fbtFixedString<L> >& dest, char c, char e = '\0') const
+	{
+		FBTuint16 i, p = 0, t;
+		for (i = 0; i < L && i < m_size; ++i)
+		{
+			if (m_buffer[i] == c || m_buffer[i] == e)
+			{
+				fbtFixedString<L> cpy;
+				for (t = p; t < i; ++t) cpy.push_back(m_buffer[t]);
+				dest.push_back(cpy);
+				p = i + 1;
+			}
+		}
+
+		if (p != i)
+		{
+			fbtFixedString<L> cpy;
+			for (t = p; t < i; ++t) cpy.push_back(m_buffer[t]);
+			dest.push_back(cpy);
+		}
+	}
+
+
+	void resize(FBTuint16 ns)
+	{
+		if (ns <= L)
+		{
+			if (ns < m_size)
+				for (FBTuint16 i = ns; i < m_size; i++) m_buffer[i] = 0;
+			else
+				for (FBTuint16 i = m_size; i < ns; i++) m_buffer[i] = 0;
+			m_size = ns;
+			m_buffer[m_size] = 0;
+		}
+	}
+
+
+
+	template<const FBTuint16 OL>
+	fbtFixedString<L>& operator = (const fbtFixedString<OL>& o)
+	{
+		if (o.m_size > 0)
+		{
+			if (m_hash == FBT_NPOS || m_hash != o.m_hash)
+			{
+				FBTuint16 i;
+				m_size = 0;
+				m_hash = o.m_hash;
+				for (i = 0; (i < L && i < OL) && i < o.m_size; ++i, ++m_size) m_buffer[i] = o.m_buffer[i];
+				m_buffer[m_size] = 0;
+			}
+		}
+		return *this;
+	}
+
+	FBT_INLINE const char* c_str(void) const                 { return m_buffer; }
+	FBT_INLINE char* ptr(void)                               { return m_buffer; }
+	FBT_INLINE const char* ptr(void) const                   { return m_buffer; }
+	FBT_INLINE const char operator [](FBTuint16 i) const     { FBT_ASSERT(i < L); return m_buffer[i]; }
+	FBT_INLINE const char at(FBTuint16 i) const              { FBT_ASSERT(i < L); return m_buffer[i]; }
+	FBT_INLINE void clear(void)                              { m_buffer[0] = 0; m_size = 0; }
+	FBT_INLINE int empty(void) const                         { return m_size == 0; }
+	FBT_INLINE int size(void) const                          { return m_size; }
+	FBT_INLINE int capacity(void) const                      { return L; }
+
+
+
+	FBTsize hash(void) const
+	{
+		if (m_hash != FBT_NPOS)
+			return m_hash;
+
+		if (m_size == 0 || !m_buffer)
+			return FBT_NPOS;
+		fbtCharHashKey chk(m_buffer);
+		m_hash = chk.hash();
+		return m_hash;
+	}
+
+	FBT_INLINE bool operator == (const fbtFixedString& str) const { return hash() == str.hash(); }
+	FBT_INLINE bool operator != (const fbtFixedString& str) const { return !(this->operator ==(str));}
+
+protected:
+
+	Pointer             m_buffer;
+	FBTuint16           m_size;
+	mutable FBThash     m_hash;
+};
+
+
+enum FBT_PRIM_TYPE
+{
+	FBT_PRIM_CHAR,		// 0
+	FBT_PRIM_UCHAR,		// 1
+	FBT_PRIM_SHORT,		// 2
+	FBT_PRIM_USHORT,	// 3
+	FBT_PRIM_INT,		// 4
+	FBT_PRIM_LONG,		// 5
+	FBT_PRIM_ULONG,		// 6
+	FBT_PRIM_FLOAT,		// 7
+	FBT_PRIM_DOUBLE,	// 8
+	FBT_PRIM_VOID,		// 9
+	FBT_PRIM_UNKNOWN	// 10
+};
+
+FBT_PRIM_TYPE fbtGetPrimType(FBTuint32 typeKey);
+FBT_INLINE FBT_PRIM_TYPE fbtGetPrimType(const char* typeName)
+{
+	return fbtGetPrimType(fbtCharHashKey(typeName).hash());
+}
+FBT_INLINE bool fbtIsIntType(FBTuint32 typeKey)
+{
+	FBT_PRIM_TYPE tp = fbtGetPrimType(typeKey);
+	return tp < FBT_PRIM_FLOAT;
+}
+FBT_INLINE bool fbtIsFloatType(FBTuint32 typeKey)
+{
+	FBT_PRIM_TYPE tp = fbtGetPrimType(typeKey);
+	return tp == FBT_PRIM_FLOAT || tp == FBT_PRIM_DOUBLE;
+}
+FBT_INLINE bool fbtIsNumberType(FBTuint32 typeKey)
+{
+	FBT_PRIM_TYPE tp = fbtGetPrimType(typeKey);
+	return tp != FBT_PRIM_VOID && tp != FBT_PRIM_UNKNOWN;
+}
+
+
+
+/** @}*/
+#endif//_fbtTypes_h_
Index: extern/FileTools/File/Generated/fbtScanner.inl
===================================================================
--- extern/FileTools/File/Generated/fbtScanner.inl	(revisione 0)
+++ extern/FileTools/File/Generated/fbtScanner.inl	(revisione 0)
@@ -0,0 +1,2317 @@
+#define yy_create_buffer fbt_create_buffer
+#define yy_delete_buffer fbt_delete_buffer
+#define yy_scan_buffer fbt_scan_buffer
+#define yy_scan_string fbt_scan_string
+#define yy_scan_bytes fbt_scan_bytes
+#define yy_flex_debug fbt_flex_debug
+#define yy_init_buffer fbt_init_buffer
+#define yy_flush_buffer fbt_flush_buffer
+#define yy_load_buffer_state fbt_load_buffer_state
+#define yy_switch_to_buffer fbt_switch_to_buffer
+#define yyin fbtin
+#define yyleng fbtleng
+#define yylex fbtlex
+#define yyout fbtout
+#define yyrestart fbtrestart
+#define yytext fbttext
+
+/* A lexical scanner generated by flex */
+
+/* Scanner skeleton version:
+ * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.85 95/04/24 10:48:47 vern Exp $
+ */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+
+#include <stdio.h>
+
+
+/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+
+
+#ifdef __cplusplus
+
+#include <stdlib.h>
+//nclude <unistd.h>
+
+/* Use prototypes in function declarations. */
+#define YY_USE_PROTOS
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_PROTOS
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef __TURBOC__
+ #pragma warn -rch
+ #pragma warn -use
+#include <io.h>
+#include <stdlib.h>
+#define YY_USE_CONST
+#define YY_USE_PROTOS
+#endif
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+
+#ifdef YY_USE_PROTOS
+#define YY_PROTO(proto) proto
+#else
+#define YY_PROTO(proto) ()
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN yy_start = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((yy_start - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#define YY_BUF_SIZE 16384
+
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+
+extern int yyleng;
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+/* The funky do-while in the following #define is used to turn the definition
+ * int a single C statement (which needs a semi-colon terminator).  This
+ * avoids problems with code like:
+ *
+ * 	if ( condition_holds )
+ *		yyless( 5 );
+ *	else
+ *		do_something_else();
+ *
+ * Prior to using the do-while the compiler would get upset at the
+ * "else" because it interpreted the "if" statement as being all
+ * done when it reached the ';' after the yyless() call.
+ */
+
+/* Return all but the first 'n' matched characters back to the input stream. */
+
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		*yy_cp = yy_hold_char; \
+		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, yytext_ptr )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+typedef unsigned int yy_size_t;
+
+
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+	};
+
+static YY_BUFFER_STATE yy_current_buffer = 0;
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ */
+#define YY_CURRENT_BUFFER yy_current_buffer
+
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+
+
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 1;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart YY_PROTO(( FILE *input_file ));
+
+void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
+void yy_load_buffer_state YY_PROTO(( void ));
+YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
+void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
+void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
+
+YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
+YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
+YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
+
+static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
+static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
+static void yy_flex_free YY_PROTO(( void * ));
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+
+
+#define yywrap() 1
+#define YY_SKIP_YYWRAP
+typedef unsigned char YY_CHAR;
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+typedef int yy_state_type;
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state YY_PROTO(( void ));
+static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
+static int yy_get_next_buffer YY_PROTO(( void ));
+static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	yytext_ptr = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	yy_hold_char = *yy_cp; \
+	*yy_cp = '\0'; \
+	yy_c_buf_p = yy_cp;
+
+#define YY_NUM_RULES 98
+#define YY_END_OF_BUFFER 99
+static yyconst short int yy_accept[322] =
+    {   0,
+        0,    0,    4,    4,   53,   53,   91,   91,   96,   96,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,   99,   98,    1,    3,   11,   14,   98,   98,
+       98,   98,   98,   58,   55,   57,   48,   49,   44,   50,
+       98,   54,   51,   52,   45,   46,   52,   52,   52,   52,
+       52,   52,   52,   52,   52,   52,   52,   52,   47,   98,
+       88,   90,   92,   98,   93,   95,   97,   98,   59,   61,
+       98,   63,   64,   66,   98,   68,   69,   71,   98,   73,
+       76,   78,   82,   98,   98,   15,   16,   83,   85,   87,
+       86,    2,    0,   14,   12,    0,    0,    0,    0,    0,
+
+       56,   24,   25,   17,    0,   54,   54,   52,   52,   52,
+       52,   52,   52,   52,   52,   52,   52,   52,   52,   52,
+       52,   52,   52,   52,   52,   52,   52,   52,   52,    0,
+       53,    0,   89,   92,    0,   91,    0,   94,   97,    0,
+       96,    0,   60,   62,   63,   65,   67,   68,   70,   72,
+       73,   77,   82,   74,    0,    0,    0,   15,   84,   87,
+       10,   13,    0,    0,    0,    0,   18,   52,   52,   52,
+       52,   52,   52,   30,   52,   52,   52,   52,   52,   52,
+       52,   52,   52,   52,   52,   52,   52,   52,   52,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,   75,    0,    0,    0,   10,    0,    9,    0,    0,
+       52,   26,   52,   52,   23,   52,   32,   52,   52,   52,
+       52,   52,   52,   52,   52,   52,   31,   52,   52,   52,
+       37,    0,    0,    0,    8,    0,    0,   52,   39,   52,
+       34,   52,   52,   52,   52,   28,   52,   52,   52,   52,
+       27,   33,   52,   52,    0,    0,    0,    0,    4,    0,
+        0,    7,   52,   35,   52,   52,   52,   52,   40,   42,
+       38,   52,   52,   29,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    5,    0,   36,   52,   52,   52,   20,
+       43,   52,    0,    0,   79,    0,    0,    0,    0,    0,
+
+        0,   21,   19,   52,   41,   80,    0,    0,    6,    0,
+       52,    0,    0,    0,   22,   81,    0,    0,    0,    0,
+        0
+    } ;
+
+static yyconst int yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        4,    4,    5,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    1,    6,    1,    1,    1,    1,    7,
+        8,    9,    1,   10,    1,   11,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   14,   15,    1,
+        1,    1,    1,    1,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   16,   16,   17,   16,   16,   16,   16,
+       16,   16,   18,   16,   19,   16,   16,   16,   16,   16,
+       20,    1,   21,    1,   16,    1,   22,   23,   24,   25,
+
+       26,   27,   28,   29,   30,   31,   31,   32,   33,   34,
+       35,   36,   31,   37,   38,   39,   40,   41,   31,   31,
+       42,   31,   43,    1,   44,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst int yy_meta[45] =
+    {   0,
+        1,    2,    3,    1,    3,    1,    1,    1,    1,    1,
+        1,    1,    4,    1,    5,    6,    6,    6,    6,    1,
+        1,    6,    6,    6,    6,    6,    6,    6,    6,    6,
+        6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
+        6,    6,    1,    1
+    } ;
+
+static yyconst short int yy_base[342] =
+    {   0,
+        0,    0,    0,    0,   38,    0,   80,   81,   84,   85,
+        4,    5,   14,   24,   94,   95,  104,  107,  143,    0,
+      185,  186,  748,  749,  749,  744,    0,  735,    9,  713,
+      710,  721,  703,  749,  749,  738,   28,    0,  749,  749,
+       19,  181,  749,    0,  749,  749,  104,  218,   79,   98,
+      102,  104,  170,  172,  178,  174,  190,  209,  749,  111,
+      749,  737,  728,  224,  749,  735,  726,  225,  749,  733,
+      723,  723,  749,  730,  720,  720,  749,  727,  717,  717,
+      749,  724,  715,  130,  155,    0,  749,  749,  722,  713,
+      749,  749,    0,  712,  749,    0,  700,  681,  687,  682,
+
+      749,   92,    0,  749,    0,  229,  226,    0,  694,  186,
+      227,  231,  222,  235,  236,  241,  223,  247,  249,  254,
+      256,  265,  263,  261,  269,  275,  276,  277,  283,  309,
+      673,  314,  749,  705,  315,  668,  318,  749,  697,  317,
+      663,  321,  749,  749,  691,  749,  749,  687,  749,  749,
+      686,  749,  681,  749,    0,  261,  663,    0,  749,  670,
+      670,    0,  633,  632,  633,  615,    0,  629,  289,  306,
+      314,  316,  318,  293,  323,  324,  325,  310,  329,  338,
+      330,  331,  347,  346,  345,  351,  357,  359,  367,  326,
+      380,  388,  391,  395,  396,  400,  403,  405,  406,  410,
+
+      415,    0,  609,  607,  613,  635,  602,  749,  599,  610,
+      599,  390,  395,  397,  402,  403,  407,  415,  414,  419,
+      423,  428,  429,  439,  440,  438,  409,  445,  450,  451,
+      452,  594,  589,  584,  474,  577,  541,  556,  458,  465,
+      463,  464,  472,  476,  478,  477,  486,  488,  484,  493,
+      492,  497,  498,  499,  496,  490,  461,  484,  442,  531,
+      442,  532,  419,  507,  511,  521,  519,  527,  520,  525,
+      531,  535,  539,  537,  424,  406,  400,  377,  540,  559,
+      568,  376,  571,  343,  574,    0,  561,  563,  553,  749,
+      559,  569,  286,  248,  749,  211,  206,  186,  582,  594,
+
+      597,  749,  749,  579,  571,  749,  198,  173,  749,  156,
+      588,  127,   99,   95,  749,  749,  603,   78,   54,  604,
+      749,  620,   14,  626,  629,  632,  637,  642,  647,  650,
+      656,  662,  668,  673,  678,  683,  689,  694,  699,  704,
+      709
+    } ;
+
+static yyconst short int yy_def[342] =
+    {   0,
+      322,  322,  322,    3,  321,    5,  322,  322,  322,  322,
+      322,  322,  322,  322,  322,  322,  322,  322,  321,   19,
+      322,  322,  321,  321,  321,  321,  323,  321,  321,  321,
+      321,  321,  321,  321,  321,  321,  321,  324,  321,  321,
+      321,  321,  321,  325,  321,  321,  326,  326,   48,   48,
+       48,   48,   48,   48,   48,   48,   48,   48,  321,  327,
+      321,  321,  321,  328,  321,  321,  321,  329,  321,  321,
+      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
+      321,  321,  321,  321,  321,  330,  321,  321,  321,  321,
+      321,  321,  331,  321,  321,  332,  321,  321,  321,  321,
+
+      321,  321,  324,  321,  333,  321,  321,  325,  325,   48,
+       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48,   48,   48,  327,
+      321,  334,  321,  321,  328,  321,  335,  321,  321,  329,
+      321,  336,  321,  321,  321,  321,  321,  321,  321,  321,
+      321,  321,  321,  321,  337,  321,  321,  330,  321,  321,
+      331,  332,  321,  321,  321,  321,  333,  325,   48,   48,
+       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48,   48,   48,  327,
+      321,  334,  334,  328,  321,  335,  335,  329,  321,  336,
+
+      336,  337,  321,  321,  321,  331,  321,  321,  321,  321,
+      325,   48,   48,   48,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
+       48,  321,  321,  321,  338,  321,  321,  325,   48,   48,
+       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,  321,  321,  321,  338,  321,  339,
+      321,  340,  325,   48,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,  321,  321,  321,  321,  321,  339,
+      339,  321,  340,  321,  341,  325,   48,   48,   48,  321,
+       48,   48,  321,  321,  321,  321,  321,  321,  321,  341,
+
+      341,  321,  321,   48,   48,  321,  321,  321,  321,  321,
+       48,  321,  321,  321,  321,  321,  338,  321,  321,  340,
+        0,  321,  321,  321,  321,  321,  321,  321,  321,  321,
+      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
+      321
+    } ;
+
+static yyconst short int yy_nxt[794] =
+    {   0,
+      321,  321,   25,  321,   26,   27,   69,   69,   70,   70,
+       28,   29,   71,   71,   72,   72,   73,   95,   74,   93,
+       96,  321,   75,   30,   76,   31,   73,  104,   74,  102,
+      105,  321,   75,   32,   76,  321,  102,   33,   24,   34,
+       35,   34,   36,   24,   37,   38,   39,   40,   24,   41,
+       42,   24,   43,   44,   44,   44,   44,   45,   46,   47,
+       47,   48,   49,   50,   51,   47,   47,   52,   47,   53,
+       47,   47,   47,   54,   47,   55,   56,   57,   58,   47,
+       59,   60,   61,   61,   62,   62,   65,   65,   66,   66,
+       63,   63,  320,  102,   67,   67,   77,   77,   78,   78,
+
+      102,  319,   79,   79,   80,   80,   81,  110,   82,   81,
+      110,   82,  130,  113,   83,   84,  108,   83,   84,  108,
+      108,  109,  108,   64,   64,  131,  110,   68,   68,  110,
+      110,  114,  110,  115,  318,  110,  317,  116,  154,   85,
+      316,  155,   85,   24,   24,   24,   24,   24,   24,   24,
+       24,   24,   24,   24,   24,   24,   24,   24,   86,   86,
+       86,   86,   24,   24,   86,   86,   86,   86,   86,   86,
+       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,   86,   86,   86,   86,   87,   24,   88,   88,   89,
+       89,  156,  314,  106,  157,   90,   90,  107,  110,  107,
+
+      110,  110,  110,  110,  117,  110,  120,  121,  118,  110,
+      313,  119,  107,  124,  110,  123,  122,  110,  110,  125,
+      107,  126,  312,  127,  310,  135,  140,  128,   91,   91,
+      108,  309,  308,  108,  108,  109,  108,  110,  136,  141,
+      110,  106,  107,  129,  107,  107,  111,  107,  169,  112,
+      110,  110,  170,  110,  110,  110,  175,  107,  110,  110,
+      107,  171,  110,  110,  110,  107,  110,  110,  107,  110,
+      173,  178,  110,  307,  172,  110,  176,  110,  110,  174,
+      110,  177,  110,  180,  110,  110,  181,  110,  179,  184,
+      203,  110,  110,  110,  110,  204,  110,  110,  183,  306,
+
+      110,  182,  185,  110,  110,  188,  110,  110,  110,  186,
+      130,  110,  189,  187,  110,  191,  135,  110,  140,  195,
+      110,  110,  199,  131,  110,  212,  192,  130,  131,  136,
+      196,  141,  136,  200,  110,  141,  214,  110,  110,  216,
+      131,  220,  110,  213,  110,  110,  110,  110,  215,  110,
+      217,  110,  110,  110,  110,  110,  110,  110,  110,  110,
+      110,  110,  110,  219,  218,  221,  110,  226,  223,  110,
+      224,  222,  225,  110,  110,  110,  110,  110,  110,  110,
+      298,  191,  110,  227,  228,  110,  229,  110,  110,  191,
+      110,  231,  191,  230,  131,  110,  135,  195,  110,  297,
+
+      192,  195,  131,  192,  195,  131,  140,  199,  296,  136,
+      136,  199,  196,  295,  136,  196,  199,  136,  110,  141,
+      141,  110,  200,  110,  141,  110,  110,  200,  240,  141,
+      110,  110,  239,  110,  110,  110,  242,  110,  110,  244,
+      110,  241,  110,  110,  294,  110,  110,  110,  245,  293,
+      110,  110,  243,  247,  110,  286,  110,  110,  248,  110,
+      110,  246,  249,  282,  250,  278,  110,  110,  110,  110,
+      110,  110,  252,  110,  251,  258,  110,  253,  110,  110,
+      110,  110,  110,  110,  277,  258,  110,  254,  259,  110,
+      264,  110,  110,  110,  110,  110,  110,  266,  259,  267,
+
+      110,  268,  265,  110,  110,  110,  110,  110,  110,  110,
+      269,  270,  110,  276,  110,  110,  110,  110,  272,  110,
+      110,  110,  271,  110,  110,  110,  110,  110,  110,  110,
+      110,  273,  279,  283,  275,  110,  287,  274,  110,  110,
+      290,  279,  110,  280,  288,  259,  284,  110,  110,  110,
+      110,  110,  110,  110,  259,  110,  110,  289,  110,  110,
+      279,  291,  110,  110,  292,  110,  110,  110,  110,  279,
+      110,  280,  283,  259,  302,  299,  303,  263,  304,  262,
+      280,  110,  259,  299,  110,  284,  300,  110,  284,  110,
+      110,  110,  110,  305,  110,  299,  284,  110,  299,  110,
+
+      110,  315,  110,  311,  258,  283,  300,  110,  284,  300,
+      110,  284,  261,  257,  256,  255,  110,  259,  284,  110,
+       24,   24,   24,   24,   24,   24,  103,  103,  103,  103,
+      238,  103,  108,  237,  108,  110,  236,  110,  132,  235,
+      206,  132,  132,  137,  234,  233,  137,  137,  142,  232,
+      211,  142,  142,  158,  210,  158,  161,  161,  209,  161,
+      161,  161,  162,  162,  208,  162,  162,  162,  167,  167,
+      207,  167,  167,  167,  193,  206,  193,  193,  193,  197,
+      160,  197,  197,  197,  201,  205,  201,  201,  201,  202,
+      202,  153,  202,  202,  202,  260,  151,  148,  260,  260,
+
+      281,  145,  281,  281,  281,  285,  198,  139,  285,  285,
+      301,  194,  301,  301,  301,  134,  190,  168,  166,  165,
+      164,  163,   94,  160,  159,  153,  152,  151,  150,  149,
+      148,  147,  146,  145,  144,  143,  139,  138,  134,  133,
+      101,  100,   99,   98,   97,   94,   92,  321,   23,  321,
+      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
+      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
+      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
+      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
+      321,  321,  321
+
+    } ;
+
+static yyconst short int yy_chk[794] =
+    {   0,
+        0,    0,    3,    0,    3,    3,   11,   12,   11,   12,
+        3,    3,   11,   12,   11,   12,   13,   29,   13,  323,
+       29,    0,   13,    3,   13,    3,   14,   41,   14,   37,
+       41,    0,   14,    3,   14,    0,   37,    3,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    7,    8,    7,    8,    9,   10,    9,   10,
+        7,    8,  319,  102,    9,   10,   15,   16,   15,   16,
+
+      102,  318,   15,   16,   15,   16,   17,   49,   17,   18,
+       49,   18,   60,   49,   17,   17,   47,   18,   18,   47,
+       47,   47,   47,    7,    8,   60,   50,    9,   10,   50,
+       51,   50,   52,   51,  314,   52,  313,   52,   84,   17,
+      312,   84,   18,   19,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19,   21,   22,   21,
+       22,   85,  310,   42,   85,   21,   22,   42,   53,   42,
+
+       54,   53,   56,   54,   53,   56,   55,   55,   54,   55,
+      308,   54,   42,   57,  110,   56,   55,  110,   57,   57,
+       42,   57,  307,   57,  298,   64,   68,   57,   21,   22,
+       48,  297,  296,   48,   48,   48,   48,   58,   64,   68,
+       58,  106,  107,   58,  107,  106,   48,  106,  111,   48,
+      113,  117,  112,  113,  117,  111,  117,  107,  111,  112,
+      106,  113,  112,  114,  115,  107,  114,  115,  106,  116,
+      115,  119,  116,  294,  114,  118,  118,  119,  118,  116,
+      119,  118,  120,  121,  121,  120,  122,  121,  120,  124,
+      156,  123,  124,  122,  123,  156,  122,  125,  123,  293,
+
+      125,  122,  125,  126,  127,  128,  126,  127,  128,  126,
+      130,  129,  129,  127,  129,  132,  135,  169,  140,  137,
+      169,  174,  142,  130,  174,  169,  132,  190,  132,  135,
+      137,  140,  137,  142,  170,  142,  171,  170,  178,  173,
+      190,  178,  171,  170,  172,  171,  173,  172,  172,  173,
+      175,  175,  176,  177,  175,  176,  177,  179,  181,  182,
+      179,  181,  182,  177,  176,  179,  180,  184,  181,  180,
+      182,  180,  183,  185,  184,  183,  185,  184,  183,  186,
+      284,  191,  186,  185,  186,  187,  187,  188,  187,  192,
+      188,  189,  193,  188,  191,  189,  194,  195,  189,  282,
+
+      192,  196,  192,  193,  197,  193,  198,  199,  278,  194,
+      195,  200,  196,  277,  196,  197,  201,  197,  212,  198,
+      199,  212,  200,  213,  200,  214,  213,  201,  214,  201,
+      215,  216,  213,  215,  216,  217,  218,  227,  217,  219,
+      227,  216,  219,  218,  276,  219,  218,  220,  220,  275,
+      220,  221,  218,  222,  221,  263,  222,  223,  223,  222,
+      223,  221,  224,  261,  225,  259,  226,  224,  225,  226,
+      224,  225,  228,  228,  226,  235,  228,  229,  229,  230,
+      231,  229,  230,  231,  257,  258,  239,  230,  235,  239,
+      240,  241,  242,  240,  241,  242,  240,  243,  258,  244,
+
+      243,  245,  242,  243,  244,  246,  245,  244,  246,  245,
+      247,  248,  249,  256,  247,  249,  248,  247,  250,  248,
+      251,  250,  249,  251,  250,  252,  253,  254,  252,  253,
+      254,  253,  260,  262,  255,  264,  265,  254,  264,  265,
+      268,  279,  265,  260,  266,  260,  262,  267,  269,  266,
+      267,  269,  266,  270,  279,  268,  270,  267,  268,  271,
+      280,  272,  271,  272,  273,  274,  272,  273,  274,  281,
+      273,  280,  283,  280,  287,  285,  288,  238,  289,  237,
+      281,  289,  281,  299,  289,  283,  285,  291,  285,  287,
+      291,  288,  287,  292,  288,  300,  299,  292,  301,  305,
+
+      292,  311,  305,  304,  317,  320,  300,  304,  300,  301,
+      304,  301,  236,  234,  233,  232,  311,  317,  320,  311,
+      322,  322,  322,  322,  322,  322,  324,  324,  324,  324,
+      211,  324,  325,  210,  325,  326,  209,  326,  327,  207,
+      206,  327,  327,  328,  205,  204,  328,  328,  329,  203,
+      168,  329,  329,  330,  166,  330,  331,  331,  165,  331,
+      331,  331,  332,  332,  164,  332,  332,  332,  333,  333,
+      163,  333,  333,  333,  334,  161,  334,  334,  334,  335,
+      160,  335,  335,  335,  336,  157,  336,  336,  336,  337,
+      337,  153,  337,  337,  337,  338,  151,  148,  338,  338,
+
+      339,  145,  339,  339,  339,  340,  141,  139,  340,  340,
+      341,  136,  341,  341,  341,  134,  131,  109,  100,   99,
+       98,   97,   94,   90,   89,   83,   82,   80,   79,   78,
+       76,   75,   74,   72,   71,   70,   67,   66,   63,   62,
+       36,   33,   32,   31,   30,   28,   26,   23,  321,  321,
+      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
+      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
+      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
+      321,  321,  321,  321,  321,  321,  321,  321,  321,  321,
+      321,  321,  321
+
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+char *yytext;
+#define INITIAL 0
+/*
+-------------------------------------------------------------------------------
+    This file is part of FBT (File Binary Table.).
+    http://gamekit.googlecode.com/
+
+    Copyright (c) 2010 Charlie C & Erwin Coumans.
+
+-------------------------------------------------------------------------------
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+-------------------------------------------------------------------------------
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <memory.h>
+#ifdef _MSC_VER
+#pragma warning(disable : 4996)
+#endif
+
+// Scalar types are defined as [a-z]"Scalar"
+// using camel hump notation
+#ifdef FBT_SCALAR_DOUBLE
+#define scalar_t double
+#else
+#define scalar_t float
+#endif
+
+
+typedef enum fbtTokenID {
+
+    COMMA       = ',',
+    POINTER     = '*',
+    LBRACE      = '[',
+    RBRACE      = ']',
+    LPARN       = '(',
+    RPARN       = ')',
+    LBRACKET    = '{',
+    RBRACKET    = '}',
+    TERM        = ';',
+
+
+    IDENTIFIER = 256,
+    CHAR,
+    SHORT,
+    INT,
+    LONG,
+    FLOAT,
+    DOUBLE,
+    SCALAR,
+    VOID,
+    FUNCTION_POINTER_BEG,
+    FUNCTION_POINTER_END,
+    CONSTANT,
+
+    NAMESPACE,
+    CLASS,
+    STRUCT,
+    UNION, // watch it not skipped or parsed yet... 
+
+    NULL_TOKEN,
+}fbtTokenID;
+
+#define FBT_TOK_IS_TYPE(x) (x >= IDENTIFIER && x <= VOID)
+#define ECHO 
+
+int line = 1;
+fbtFixedString<270> __source;
+
+
+
+#define YY_NEVER_INTERACTIVE 1
+#define OSTRC 1
+#define ISTRC 2
+#define IGENUM 3
+#define ISENUM 4
+#define ICMT 5
+#define GCMT 6
+#define PSCMT 7
+#define PRIVSEC 8
+#define INSP 9
+#define SSTRC 10
+
+FBTsize         m_lastConstant;
+
+
+struct fbtToken
+{
+    fbtTokenID  m_cur;
+    char*       m_buf;
+    FBTsize     m_constantSize;
+    FBTsize     m_line;
+    char*       m_src;
+};
+
+
+
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap YY_PROTO(( void ));
+#else
+extern int yywrap YY_PROTO(( void ));
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+static void yyunput YY_PROTO(( int c, char *buf_ptr ));
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput YY_PROTO(( void ));
+#else
+static int input YY_PROTO(( void ));
+#endif
+#endif
+
+#if YY_STACK_USED
+static int yy_start_stack_ptr = 0;
+static int yy_start_stack_depth = 0;
+static int *yy_start_stack = 0;
+#ifndef YY_NO_PUSH_STATE
+static void yy_push_state YY_PROTO(( int new_state ));
+#endif
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state YY_PROTO(( void ));
+#endif
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state YY_PROTO(( void ));
+#endif
+
+#else
+#define YY_NO_PUSH_STATE 1
+#define YY_NO_POP_STATE 1
+#define YY_NO_TOP_STATE 1
+#endif
+
+#ifdef YY_MALLOC_DECL
+YY_MALLOC_DECL
+#else
+#if __STDC__
+#ifndef __cplusplus
+#include <stdlib.h>
+#endif
+#else
+/* Just try to get by without declaring the routines.  This will fail
+ * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
+ * or sizeof(void*) != sizeof(int).
+ */
+#endif
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( yy_current_buffer->yy_is_interactive ) \
+		{ \
+		int c = '*', n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
+		  && ferror( yyin ) ) \
+		YY_FATAL_ERROR( "input in flex scanner failed" );
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL int yylex YY_PROTO(( void ))
+#endif
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+YY_DECL
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+
+
+
+
+	if ( yy_init )
+		{
+		yy_init = 0;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! yy_start )
+			yy_start = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! yy_current_buffer )
+			yy_current_buffer =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+
+		yy_load_buffer_state();
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = yy_c_buf_p;
+
+		/* Support of yytext. */
+		*yy_cp = yy_hold_char;
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = yy_start;
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				yy_last_accepting_state = yy_current_state;
+				yy_last_accepting_cpos = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 322 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 749 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+
+do_action:	/* This label is used only to access EOF actions. */
+
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = yy_hold_char;
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+{ BEGIN INSP;  return (NAMESPACE); }
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+{ BEGIN ISTRC; return STRUCT; }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+{ BEGIN ISTRC; return STRUCT; }
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+{ BEGIN IGENUM; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+{ BEGIN SSTRC; }
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+{ BEGIN GCMT; }
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+{ return IDENTIFIER; }
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{ BEGIN OSTRC; }
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+{ BEGIN ICMT; }
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{ BEGIN PRIVSEC;}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+{ BEGIN ISENUM; }
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{ return FUNCTION_POINTER_BEG; }
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+{ return FUNCTION_POINTER_END; }
+	YY_BREAK
+case 26:
+case 27:
+YY_RULE_SETUP
+{ return CHAR; }
+	YY_BREAK
+case 28:
+case 29:
+YY_RULE_SETUP
+{ return SHORT; }
+	YY_BREAK
+case 30:
+case 31:
+YY_RULE_SETUP
+{ return INT; }
+	YY_BREAK
+case 32:
+case 33:
+YY_RULE_SETUP
+{ return LONG;      }
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+{ return FLOAT;     }
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+{ return DOUBLE;    }
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+{ return SCALAR;    }
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+{ return VOID;      }
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+{ return POINTER;       }
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+{ return LBRACE;        }
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+{ return RBRACE;        }
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+{ return LBRACKET;      }
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+{ return LPARN;         }
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+{ return RPARN;         }
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+{ return COMMA;         }
+	YY_BREAK
+case 51:
+YY_RULE_SETUP
+{ return TERM;          }
+	YY_BREAK
+case 52:
+YY_RULE_SETUP
+{ return IDENTIFIER;    }
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+{ BEGIN OSTRC; return RBRACKET; }
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+{ m_lastConstant = atoi(yytext); return(CONSTANT); }
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 56:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 57:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 58:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 59:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 60:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 61:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 62:
+YY_RULE_SETUP
+{ BEGIN ISTRC; }
+	YY_BREAK
+case 63:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 64:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 65:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 66:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 67:
+YY_RULE_SETUP
+{ BEGIN OSTRC; }
+	YY_BREAK
+case 68:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 69:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 70:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 71:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 72:
+YY_RULE_SETUP
+{ BEGIN PRIVSEC; }
+	YY_BREAK
+case 73:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 74:
+YY_RULE_SETUP
+{ BEGIN PSCMT; }
+	YY_BREAK
+case 75:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 76:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 77:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 78:
+YY_RULE_SETUP
+{ line ++; }
+	YY_BREAK
+case 79:
+YY_RULE_SETUP
+{ BEGIN ISTRC; }
+	YY_BREAK
+case 80:
+YY_RULE_SETUP
+{ BEGIN ISTRC; }
+	YY_BREAK
+case 81:
+YY_RULE_SETUP
+{ BEGIN ISTRC; }
+	YY_BREAK
+case 82:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 83:
+YY_RULE_SETUP
+{ line ++;      }
+	YY_BREAK
+case 84:
+YY_RULE_SETUP
+{ line ++;      }
+	YY_BREAK
+case 85:
+YY_RULE_SETUP
+{ line ++;      }
+	YY_BREAK
+case 86:
+YY_RULE_SETUP
+{ BEGIN OSTRC;  }
+	YY_BREAK
+case 87:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 88:
+YY_RULE_SETUP
+{ line ++;      }
+	YY_BREAK
+case 89:
+YY_RULE_SETUP
+{ line ++;      }
+	YY_BREAK
+case 90:
+YY_RULE_SETUP
+{ line ++;      }
+	YY_BREAK
+case 91:
+YY_RULE_SETUP
+{ BEGIN OSTRC;  }
+	YY_BREAK
+case 92:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 93:
+YY_RULE_SETUP
+{ line ++;      }
+	YY_BREAK
+case 94:
+YY_RULE_SETUP
+{ line ++;      }
+	YY_BREAK
+case 95:
+YY_RULE_SETUP
+{ line ++;      }
+	YY_BREAK
+case 96:
+YY_RULE_SETUP
+{ BEGIN ISTRC;  }
+	YY_BREAK
+case 97:
+YY_RULE_SETUP
+{ }
+	YY_BREAK
+case 98:
+YY_RULE_SETUP
+ECHO;
+	YY_BREAK
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(OSTRC):
+case YY_STATE_EOF(ISTRC):
+case YY_STATE_EOF(IGENUM):
+case YY_STATE_EOF(ISENUM):
+case YY_STATE_EOF(ICMT):
+case YY_STATE_EOF(GCMT):
+case YY_STATE_EOF(PSCMT):
+case YY_STATE_EOF(PRIVSEC):
+case YY_STATE_EOF(INSP):
+case YY_STATE_EOF(SSTRC):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = yy_hold_char;
+
+		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between yy_current_buffer and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			yy_n_chars = yy_current_buffer->yy_n_chars;
+			yy_current_buffer->yy_input_file = yyin;
+			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state();
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = yytext_ptr + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++yy_c_buf_p;
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = yy_c_buf_p;
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer() )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				yy_did_buffer_switch_on_eof = 0;
+
+				if ( yywrap() )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				yy_c_buf_p =
+					yytext_ptr + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				yy_c_buf_p =
+				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of yylex */
+
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+
+static int yy_get_next_buffer()
+	{
+	register char *dest = yy_current_buffer->yy_ch_buf;
+	register char *source = yytext_ptr;
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( yy_current_buffer->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a singled characater, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		yy_n_chars = 0;
+
+	else
+		{
+		int num_to_read =
+			yy_current_buffer->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+#ifdef YY_USES_REJECT
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+#else
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = yy_current_buffer;
+
+			int yy_c_buf_p_offset =
+				(int) (yy_c_buf_p - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yy_flex_realloc( (void *) b->yy_ch_buf,
+							 b->yy_buf_size + 2 );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = yy_current_buffer->yy_buf_size -
+						number_to_move - 1;
+#endif
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
+			yy_n_chars, num_to_read );
+		}
+
+	if ( yy_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			yy_current_buffer->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	yy_n_chars += number_to_move;
+	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+
+	return ret_val;
+	}
+
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+static yy_state_type yy_get_previous_state()
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+
+	yy_current_state = yy_start;
+
+	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			yy_last_accepting_state = yy_current_state;
+			yy_last_accepting_cpos = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 322 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+	}
+
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+
+#ifdef YY_USE_PROTOS
+static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
+#else
+static yy_state_type yy_try_NUL_trans( yy_current_state )
+yy_state_type yy_current_state;
+#endif
+	{
+	register int yy_is_jam;
+	register char *yy_cp = yy_c_buf_p;
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		yy_last_accepting_state = yy_current_state;
+		yy_last_accepting_cpos = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 322 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 321);
+
+	return yy_is_jam ? 0 : yy_current_state;
+	}
+
+
+#ifndef YY_NO_UNPUT
+#ifdef YY_USE_PROTOS
+static void yyunput( int c, register char *yy_bp )
+#else
+static void yyunput( c, yy_bp )
+int c;
+register char *yy_bp;
+#endif
+	{
+	register char *yy_cp = yy_c_buf_p;
+
+	/* undo effects of setting up yytext */
+	*yy_cp = yy_hold_char;
+
+	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = yy_n_chars + 2;
+		register char *dest = &yy_current_buffer->yy_ch_buf[
+					yy_current_buffer->yy_buf_size + 2];
+		register char *source =
+				&yy_current_buffer->yy_ch_buf[number_to_move];
+
+		while ( source > yy_current_buffer->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		yy_n_chars = yy_current_buffer->yy_buf_size;
+
+		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+
+	yytext_ptr = yy_bp;
+	yy_hold_char = *yy_cp;
+	yy_c_buf_p = yy_cp;
+	}
+#endif	/* ifndef YY_NO_UNPUT */
+
+
+#ifdef __cplusplus
+static int yyinput()
+#else
+static int input()
+#endif
+	{
+	int c;
+
+	*yy_c_buf_p = yy_hold_char;
+
+	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			/* This was really a NUL. */
+			*yy_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			yytext_ptr = yy_c_buf_p;
+			++yy_c_buf_p;
+
+			switch ( yy_get_next_buffer() )
+				{
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap() )
+						{
+						yy_c_buf_p =
+						yytext_ptr + YY_MORE_ADJ;
+						return EOF;
+						}
+
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+					break;
+
+				case EOB_ACT_LAST_MATCH:
+#ifdef __cplusplus
+					YY_FATAL_ERROR(
+					"unexpected last match in yyinput()" );
+#else
+					YY_FATAL_ERROR(
+					"unexpected last match in input()" );
+#endif
+				}
+			}
+		}
+
+	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
+	*yy_c_buf_p = '\0';	/* preserve yytext */
+	yy_hold_char = *++yy_c_buf_p;
+
+
+	return c;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yyrestart( FILE *input_file )
+#else
+void yyrestart( input_file )
+FILE *input_file;
+#endif
+	{
+	if ( ! yy_current_buffer )
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+
+	yy_init_buffer( yy_current_buffer, input_file );
+	yy_load_buffer_state();
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
+#else
+void yy_switch_to_buffer( new_buffer )
+YY_BUFFER_STATE new_buffer;
+#endif
+	{
+	if ( yy_current_buffer == new_buffer )
+		return;
+
+	if ( yy_current_buffer )
+		{
+		/* Flush out information for old buffer. */
+		*yy_c_buf_p = yy_hold_char;
+		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	yy_current_buffer = new_buffer;
+	yy_load_buffer_state();
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	yy_did_buffer_switch_on_eof = 1;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_load_buffer_state( void )
+#else
+void yy_load_buffer_state()
+#endif
+	{
+	yy_n_chars = yy_current_buffer->yy_n_chars;
+	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
+	yyin = yy_current_buffer->yy_input_file;
+	yy_hold_char = *yy_c_buf_p;
+	}
+
+
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
+#else
+YY_BUFFER_STATE yy_create_buffer( file, size )
+FILE *file;
+int size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_delete_buffer( YY_BUFFER_STATE b )
+#else
+void yy_delete_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+	{
+	if ( ! b )
+		return;
+
+	if ( b == yy_current_buffer )
+		yy_current_buffer = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yy_flex_free( (void *) b->yy_ch_buf );
+
+	yy_flex_free( (void *) b );
+	}
+
+
+#ifndef YY_ALWAYS_INTERACTIVE
+#ifndef YY_NEVER_INTERACTIVE
+extern int isatty YY_PROTO(( int ));
+#endif
+#endif
+
+#ifdef YY_USE_PROTOS
+void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
+#else
+void yy_init_buffer( b, file )
+YY_BUFFER_STATE b;
+FILE *file;
+#endif
+
+
+	{
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+#if YY_ALWAYS_INTERACTIVE
+	b->yy_is_interactive = 1;
+#else
+#if YY_NEVER_INTERACTIVE
+	b->yy_is_interactive = 0;
+#else
+	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+#endif
+#endif
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_flush_buffer( YY_BUFFER_STATE b )
+#else
+void yy_flush_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+
+	{
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == yy_current_buffer )
+		yy_load_buffer_state();
+	}
+
+
+#ifndef YY_NO_SCAN_BUFFER
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
+#else
+YY_BUFFER_STATE yy_scan_buffer( base, size )
+char *base;
+yy_size_t size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b );
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_STRING
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_string( yyconst char *str )
+#else
+YY_BUFFER_STATE yy_scan_string( str )
+yyconst char *str;
+#endif
+	{
+	int len;
+	for ( len = 0; str[len]; ++len )
+		;
+
+	return yy_scan_bytes( str, len );
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_BYTES
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
+#else
+YY_BUFFER_STATE yy_scan_bytes( bytes, len )
+yyconst char *bytes;
+int len;
+#endif
+	{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = len + 2;
+	buf = (char *) yy_flex_alloc( n );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
+
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_PUSH_STATE
+#ifdef YY_USE_PROTOS
+static void yy_push_state( int new_state )
+#else
+static void yy_push_state( new_state )
+int new_state;
+#endif
+	{
+	if ( yy_start_stack_ptr >= yy_start_stack_depth )
+		{
+		yy_size_t new_size;
+
+		yy_start_stack_depth += YY_START_STACK_INCR;
+		new_size = yy_start_stack_depth * sizeof( int );
+
+		if ( ! yy_start_stack )
+			yy_start_stack = (int *) yy_flex_alloc( new_size );
+
+		else
+			yy_start_stack = (int *) yy_flex_realloc(
+					(void *) yy_start_stack, new_size );
+
+		if ( ! yy_start_stack )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
+
+	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+
+	BEGIN(new_state);
+	}
+#endif
+
+
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state()
+	{
+	if ( --yy_start_stack_ptr < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
+
+	BEGIN(yy_start_stack[yy_start_stack_ptr]);
+	}
+#endif
+
+
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state()
+	{
+	return yy_start_stack[yy_start_stack_ptr - 1];
+	}
+#endif
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+#ifdef YY_USE_PROTOS
+static void yy_fatal_error( yyconst char msg[] )
+#else
+static void yy_fatal_error( msg )
+char msg[];
+#endif
+	{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+	}
+
+
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		yytext[yyleng] = yy_hold_char; \
+		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
+		yy_hold_char = *yy_c_buf_p; \
+		*yy_c_buf_p = '\0'; \
+		yyleng = n; \
+		} \
+	while ( 0 )
+
+
+/* Internal utility routines. */
+
+#ifndef yytext_ptr
+#ifdef YY_USE_PROTOS
+static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
+#else
+static void yy_flex_strncpy( s1, s2, n )
+char *s1;
+yyconst char *s2;
+int n;
+#endif
+	{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+	}
+#endif
+
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_alloc( yy_size_t size )
+#else
+static void *yy_flex_alloc( size )
+yy_size_t size;
+#endif
+	{
+	return (void *) malloc( size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_realloc( void *ptr, yy_size_t size )
+#else
+static void *yy_flex_realloc( ptr, size )
+void *ptr;
+yy_size_t size;
+#endif
+	{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void yy_flex_free( void *ptr )
+#else
+static void yy_flex_free( ptr )
+void *ptr;
+#endif
+	{
+	free( ptr );
+	}
+
+#if YY_MAIN
+int main()
+	{
+	yylex();
+	return 0;
+	}
+#endif
+
+
+fbtTokenID fbtLex()
+{
+    return (fbtTokenID)fbtlex();
+}
+
+fbtTokenID fbtLex(fbtToken &tok)
+{
+    tok.m_cur           = fbtLex();
+    tok.m_buf           = yytext;
+    tok.m_constantSize  = m_lastConstant;
+    tok.m_line          = line;
+    tok.m_src           = (char*)__source.c_str();
+    m_lastConstant      = -1;
+    return tok.m_cur;
+}
+
+void *fbtCurFile = 0;
+yy_buffer_state *fbtCurBuf = 0;
+
+void* fbtInitParse(const char *ifile)
+{
+    line    = 1;
+    BEGIN   OSTRC;
+    __source = ifile;
+
+
+    fbtCurFile = (void*)fopen(ifile, "rb");
+    if (!fbtCurFile)
+    {
+        fbtPrintf("File '%s' loading failed!\n", ifile);
+        return 0;
+    }
+
+    yyin = (FILE*)fbtCurFile;
+    return fbtCurFile;
+}
+
+
+void* fbtInitParse(const char *name, const char *buf)
+{
+    line    = 1;
+    BEGIN   OSTRC;
+    __source = name;
+
+    fbtCurBuf = fbt_scan_string(buf);
+    return fbtCurBuf;
+}
+
+void fbtFreeParse(void *p)
+{   
+    if (p == fbtCurBuf)
+    {
+        fbt_delete_buffer(fbtCurBuf);
+        return;
+    }
+
+
+    if (p == fbtCurFile)
+        fclose((FILE*)fbtCurFile);
+}
Index: source/gameengine/Converter/CMakeLists.txt
===================================================================
--- source/gameengine/Converter/CMakeLists.txt	(revisione 39518)
+++ source/gameengine/Converter/CMakeLists.txt	(copia locale)
@@ -118,4 +118,17 @@
 	add_definitions(-DWITH_AUDASPACE)
 endif()
 
+if(WITH_FBT)
+	list(APPEND INC
+		../../../extern/FileTools/File
+		../../../extern/FileTools/File/Generated
+	)
+	list(APPEND SRC
+		KX_FileInterface.cpp
+		KX_FileInterface.h
+		KX_BGEdna.h
+	)
+	add_definitions(-DWITH_FBT)
+endif()
+
 blender_add_lib(ge_converter "${SRC}" "${INC}" "${INC_SYS}")
Index: source/gameengine/Converter/KX_BGEdna.h
===================================================================
--- source/gameengine/Converter/KX_BGEdna.h	(revisione 0)
+++ source/gameengine/Converter/KX_BGEdna.h	(revisione 0)
@@ -0,0 +1,110 @@
+#ifndef _KX_BGEDNA
+#define _KX_BGEDNA
+// Generated from a Blender(256) file.
+
+
+#include <vector>
+
+/*why this?
+#ifdef near
+#undef near
+#endif
+#ifdef far
+#undef far
+#endif*/
+
+
+namespace Bgedna {
+/** \addtogroup Bgedna
+*  @{
+*/
+
+	//all structs here
+struct FileGlobal;
+struct KX_Scene;
+
+typedef std::vector<KX_Scene*> KX_SceneList;
+typedef std::vector<class RAS_MaterialBucket*> BucketList;
+
+typedef struct RAS_BucketManager {
+	
+	BucketList m_SolidBuckets;
+	BucketList m_AlphaBuckets;
+	
+	struct sortedmeshslot;
+	struct backtofront;
+	struct fronttoback;
+
+} RAS_BucketManager;
+
+struct CullingInfo {
+		int m_layer;
+	};
+
+typedef struct KX_Scene {
+
+#ifdef WITH_PYTHON
+	PyObject*	m_attr_dict;
+	PyObject*	m_draw_call_pre;
+	PyObject*	m_draw_call_post;
+#endif
+
+	RAS_BucketManager*	m_bucketmanager;
+	CListValue*			m_tempObjectList;
+	CListValue*			m_euthanasyobjects;
+	CListValue*			m_objectlist;
+	CListValue*			m_parentlist;
+	CListValue*			m_lightlist;
+	CListValue*			m_inactivelist;
+	SG_QList			m_sghead;		
+	list<class KX_Camera*>       m_cameras;
+	list<class KX_FontObject*>       m_fonts;
+	SCA_LogicManager*		m_logicmgr;
+	SCA_KeyboardManager*	m_keyboardmgr;
+	SCA_MouseManager*		m_mousemgr;
+	SCA_TimeEventManager*	m_timemgr;
+	class KX_BlenderSceneConverter*		m_sceneConverter;
+	class PHY_IPhysicsEnvironment*		m_physicsEnvironment;
+	bool m_isclearingZbuffer;
+	STR_String	m_sceneName;
+	KX_WorldInfo* m_worldinfo;
+	NG_NetworkDeviceInterface*	m_networkDeviceInterface;
+	NG_NetworkScene* m_networkScene;
+	SG_Node* m_rootnode;
+	KX_Camera* m_active_camera;
+	CTR_Map	<CTR_HashedPtr, void*> m_map_gameobject_to_replica;
+	std::vector<KX_GameObject*>	m_logicHierarchicalGameObjects;
+	std::set<CValue*>	m_groupGameObjects;
+	SCA_ISystem* m_kxsystem;
+	int	m_ueberExecutionPriority;
+	bool m_suspend;
+	float m_activity_box_radius;
+	bool m_activity_culling;
+	bool m_dbvt_culling;
+	int m_dbvt_occlusion_res;
+	RAS_FrameSettings m_frame_settings;
+	RAS_Rect m_viewport;
+	double				m_suspendedtime;
+	double				m_suspendeddelta;
+	struct Scene* m_blenderScene;
+	RAS_2DFilterManager m_filtermanager;
+	static SG_Callbacks	m_callbacks;
+
+#ifdef WITH_PYTHON
+
+	static PyMappingMethods	Mapping;
+	static PySequenceMethods	Sequence;
+#endif
+} KX_Scene;
+
+struct FileGlobal
+{
+    char subvstr[4];
+    short subversion;
+    int revision;
+    char filename[240];
+};
+
+/** @}*/
+}
+#endif//_KX_BGEDNA
\ No newline at end of file
Index: source/gameengine/Converter/KX_BlenderSceneConverter.h
===================================================================
--- source/gameengine/Converter/KX_BlenderSceneConverter.h	(revisione 39518)
+++ source/gameengine/Converter/KX_BlenderSceneConverter.h	(copia locale)
@@ -41,6 +41,10 @@
 #include "KX_ISceneConverter.h"
 #include "KX_IpoConvert.h"
 
+#ifdef WITH_FBT
+	#include "KX_FileInterface.h"
+#endif
+
 class KX_WorldInfo;
 class SCA_IActuator;
 class SCA_IController;
Index: source/gameengine/Converter/KX_FileInterface.cpp
===================================================================
--- source/gameengine/Converter/KX_FileInterface.cpp	(revisione 0)
+++ source/gameengine/Converter/KX_FileInterface.cpp	(revisione 0)
@@ -0,0 +1,134 @@
+#include "KX_FileInterface.h"
+#include "fbtTables.h"
+#include "fbtStreams.h"
+
+const FBTuint32 GLOB = FBT_ID('G', 'L', 'O', 'B');
+
+struct fbtIdDB
+{
+        const FBTuint16     m_code;
+        fbtList             KX_FileInterface::*m_ptr;
+};
+
+fbtIdDB fbtData[] =
+{
+        { FBT_ID2('S', 'C'), &KX_FileInterface::m_scene},
+		//all attributes of class here!
+        { 0, 0 }
+};
+
+
+
+
+extern unsigned char bfBgeFBT[];
+extern int bfBgeLen;
+
+
+KX_FileInterface::KX_FileInterface()
+        :   fbtFile("BGE"), m_stripList(0)
+{
+        m_aluhid = "BGEs"; //a stripped blend file
+}
+
+
+
+KX_FileInterface::~KX_FileInterface()
+{
+}
+
+
+
+int KX_FileInterface::initializeTables(fbtBinTables* tables)
+{
+        return tables->read(bfBgeFBT, bfBgeLen, false) ? FS_OK : FS_FAILED;
+}
+
+
+
+int KX_FileInterface::notifyData(void* p, const Chunk& id)
+{
+        if (id.m_code == GLOB)
+        {
+                m_fg = (Bgedna::FileGlobal*)p;
+                return FS_OK;
+        }
+
+        if ((id.m_code <= 0xFFFF))
+        {
+                int i = 0;
+                while (fbtData[i].m_code != 0)
+                {
+                        if (fbtData[i].m_code == id.m_code)
+                        {
+                                (this->*fbtData[i].m_ptr).push_back(p);
+                                break;
+                        }
+                        ++i;
+                }
+        }
+        return FS_OK;
+}
+
+
+int KX_FileInterface::writeData(fbtStream* stream)
+{
+        fbtBinTables::OffsM::Pointer md = m_memory->m_offs.ptr();
+
+
+        for (MemoryChunk* node = (MemoryChunk*)m_chunks.first; node; node = node->m_next)
+        {
+                if (node->m_newTypeId > m_memory->m_strcNr)
+                        continue;
+                if (!node->m_newBlock)
+                        continue;
+
+                void* wd = node->m_newBlock;
+
+                Chunk ch;
+                ch.m_code   = node->m_chunk.m_code;
+                ch.m_nr     = node->m_chunk.m_nr;
+                ch.m_len    = node->m_chunk.m_len;
+                ch.m_typeid = node->m_newTypeId;
+                ch.m_old    = (FBTsize)wd;
+
+                stream->write(&ch, sizeof(Chunk));
+                stream->write(wd, ch.m_len);
+        }
+
+        return FS_OK;
+}
+
+
+
+bool KX_FileInterface::skip(const FBTuint32& id)
+{
+
+        if (!m_stripList)
+                return false;
+
+        int i = 0;
+        while (m_stripList[i] != 0)
+        {
+                if (m_stripList[i++] == id)
+                        return true;
+        }
+
+        return false;
+}
+
+
+void*   KX_FileInterface::getFBT(void)
+{
+        return (void*)bfBgeFBT;
+}
+
+FBTsize KX_FileInterface::getFBTlength(void)
+{
+        return bfBgeLen;
+}
+
+int KX_FileInterface::save(const char *path, const int mode)
+{
+        m_version = m_fileVersion;
+        return reflect(path, mode);
+}
Index: source/gameengine/Converter/KX_FileInterface.h
===================================================================
--- source/gameengine/Converter/KX_FileInterface.h	(revisione 0)
+++ source/gameengine/Converter/KX_FileInterface.h	(revisione 0)
@@ -0,0 +1,35 @@
+#ifndef _KX_FILEINTERFACE
+#define _KX_FILEINTERFACE
+
+#include "fbtFile.h"
+#include "KX_BGEdna.h"
+
+class KX_FileInterface : public fbtFile
+{
+public:
+        KX_FileInterface();
+        virtual ~KX_FileInterface();
+
+
+        fbtList m_scene;// all fbtList for each thing here!
+
+        Bgedna::FileGlobal* m_fg;
+
+        int save(const char* path, const int mode = PM_UNCOMPRESSED);
+        
+        void setIgnoreList(FBTuint32 *stripList) {m_stripList = stripList;}
+
+protected:
+        virtual int notifyData(void* p, const Chunk& id);
+        virtual int initializeTables(fbtBinTables* tables);
+        virtual bool skip(const FBTuint32& id);
+        virtual int writeData(fbtStream* stream);
+
+        FBTuint32* m_stripList;
+
+        virtual void*   getFBT(void);
+        virtual FBTsize getFBTlength(void);
+};
+
+
+#endif//_KX_FILEINTERFACE
\ No newline at end of file
